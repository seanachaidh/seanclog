%resumé pour le project seanclog
%Auteur: Pieter Van Keymeulen
%Titre: Seanclog: Simple and Fancy timetracker

\documentclass[a4paper,11pt]{article}
\usepackage{listings}

%Een commando voor een mooie tabelhoofding
\newcommand{\head}[1]{\textnormal{\textbf{#1}}}

\begin{document}
\title{Seanclog: Simple and Fancy timetracker}
\author{Pieter Van Keymeulen}
\maketitle

\section{Inleiding}

\subsection{Tijd. Planning. Al het andere}
Dit project heeft zijn oorsprong in mijn eigen persoonlijkheid. Als je het mijn
vrienden zou vragen of ik een ordelijke planner ben, zouden die allemaal
éénzelfde antwoord geven. Een gezamenlijk neen. Omdat ik er vrijwel continu aan
herinnerd wordt, wou ik dit probleem aanpakken. Ik ben programmeur, en het
typische aan dit beroep is dat men ordelijk moet kunnen plannen. Een knelpuntje
voor mij dus. Ik kreeg vaak veel software toegewezen om mij hierbij te helpen.
Veel van deze software ben ik uiteindelijk beginnen gebruiken. Soms hou ik van
deze software, en soms haat ik deze software. Bij de software die ik haat heb
ik, als programmeur, altijd de neiging om deze te willen verbeteren.

Hierbij begon ik een specifieke haat te ontwikkelen voor timetrackers

\subsection{Het probleem?}
Een programmeur wilt natuurlijk op tijd betaald worden. De programmeur wordt
gehuurd, krijgt een opdracht, wordt betaald voor de gepresteerde uren. Maar hoe
moet je nu zo een factuur opstellen. Hoe weet een programmeur nu hoe lang hij
voor een bepaald project heeft gewerkt en nog belangrijker, hoe weet de klant
dat hij een goede, eerlijke prijs betaald voor de afgeleverde software? Je kan
uren spenderen aan het invullen van spreadsheets. Die naar uw klanten sturen.
Verwachten dat uw klant deze zal opmerken. Dat terwijl de klant in kwestie zelf
onder honderden mails bedolven zit en uw mail niet eens opmerkt.

\subsection{Het licht gezien!}
Na heel lang zoeken heb ik uiteindelijk de oplossing gevonden. Wanneer er geen
enkele goede oplossing ter beschikking staat rest de meesten slechts één ding.
Maak het zelf. Met dit project heb ik het doel om een timetracker te maken die
alle eigenschappen die ik aan timetrackers haat niet heeft. Hoofdzakelijk houdt
dit het volgende in.
\begin{itemize}
  \item Minder manueel invoeren
  \item Offline toegang
  \item Toegang vanop meerdere apparaten
  \item Een interface met zo weinig mogelijk afleiding
  \item Gemakkelijke filtering van ingevoerde tracks
\end{itemize}

\section{Interne structuur}

\subsection{Gebruikte software}
Voor dit project werd er bijna uitsluitend gebruik gemaakt van experimentele
technologie. Tegenwoordig worden webapplicaties vaak ontwikkeld op de zogenaamde
LAMP stack. Dit is een collectie software die meestal gebundeld gedistribueerd
wordt omdat ze tezamen de gebruiker in staat stellen tot het hosten van een
webapplicatie. De LAMP stack bestaat uit vier onderdelen.

\begin{description}
\item[Een Linux server] Dit is het besturingssysteem waarop de applicatie zal
draaien
\item[Apache] Dit is een daemon die het http protocol implementeert. Het stelt
ons in staat tot het ontvangen en het verwerken van http requests.
\item[Een MYSQL databank] Dit is te gebruiken databank bedoeld voor het oplaan
van data. Dit kan gaan om klantengegevens en productgegevens. Andere databanken
zoals postgresql zijn ook mogelijk, maar bij een LAMP stack gaat het specifiek
om MYSQL.
\item[PHP] De programmeertaal die gebruikt wordt voor het maken van de
applicatie.
\end{description}

Deze LAMP stack wordt al jaren op deze manier gebruikt. Het is vrij oude
technologie die al jaren meegaat en bijgevolg dus enorm betrouwbaar is. Het
heeft echter een aantal zwakke punten.

\begin{itemize}
  \item Het onderhoud van een linux server is een tijdrovende bezigheid.
  \item Apache is een modulair programma. Men kan functionaliteit toevoegen en
  verwijderen. Veel van de functionaliteit staat standaard aan of kan zelfs
  helemaal niet verwijderd worden. Dat terwijl de meesten niet zoveel
  functionaliteit nodig hebben. Daarbij kan het ook ervoor zorgen dat Apache
  onveiliger wordt en gemakkelijker is om in in te breken.
  \item MYSQL heeft veel limitaties. We leven in een wereld waarin data alsmaar
  meer aandacht krijgt. Bedrijven verzamelen, analyseren en gebruiken. Dit
  allemaal om hun klantenervaring zo veel mogelijk te kunnen verbeteren.
\end{itemize}

\subsubsection{Nodejs}
Nodejs is een javascript interpreter die in tegenstelling tot andere javascript interpreters niet gekoppeld is aan een webbrowser. Men kan hiermee javascripts uitvoeren alsof het gewone programma's zouden zijn. Dit heeft als neveneffect dat het ook gebruikt kan worden voor bijvoorbeeld server side scripting.

Dit is echter slecht één van de redenen waarom het een handige tool is voor het gebruik bij server side scripting. Tegenwoordig worden er alsmaar meer webapplicaties gebouwd. De bedrijven die deze webapplicaties bouwen hebben alsmaar meer klanten. Al die klanten moeten tegelijk afgehandeld worden. Computers hebben echter hun limieten. Wanneer een gebruiker een webpagina zou opvragen, betekend dat dat deze gebruiker een html bestand doorgestuurd zal moeten krijgen. Dat HTML bestand dient ingelezen en doorgestuurd te worden. Wanneer het besturingssysteem een bestand inleest betekent dat dat deze een zogezegde lock op dat bestand legt. Enkel het proces dat de leesbewerking heeft aangevraagd, mag het bestand inlezen. Van zodra dit proces gedaan heeft met lezen, wordt deze lock vrijgegeven en is het de beurt aan het volgende proces. Wanneer één van de processen die aanspraak willen maken op het bestand, nadat hij deze aanspraak gekregen heeft, in een lus gaat. Vormt dit een dead-lock. Dit wil zeggen dat alle input en output met betrekking tot dit bestand stilvalt en niemand meer aan het bestand kan. Het hele proces valt stil.

In NodeJS zijn er echter geen locks.

\subsubsection{MongoDB}
MongoDB is, in tegenstelling tot traditionele SQL databanken, een 
no-sql databank. Dit wil zeggen dat de data niet voorgesteld wordt door 
tabellen. Hoe de data dan wel voorgesteld wordt, wordt in de definitie 
van no-sql niet vervat. Over het algemeen wordt bij een gewone mysql 
databank, een collectie aan data voorgesteld door een tabel. Bij een 
nosql gaat men uit van andere metaforen die ieder beter bij het 
werkveld passen waarvoor de databank specifiek ontworpen is. Stel nu 
dat ik een complexe hiërarchie binnen een bedrijf als gegeven heb. 
Iedere werknemer van dit bedrijf heeft contacten, die op hun beurt 
contacten hebben, die op hun beurt alweer contacten hebben. Dan zou 
het leuk zijn mocht ik al de relaties die deze werknemers met elkaar 
hebben op een efficiënte manier kunnen ophalen. Wanneer men vasthoudt 
aan de klassieke tabel metafoor is dit echter heel moeilijk, maar 
wanneer we de relaties op één of andere manier op voorhand in de data 
kunnen programmeren, dan wordt het ineens een stuk makkelijker.
dat ik  Over het algemeen kan men spreken over de 
volgende types nosql databanken

\begin{description}

\item[Column]
\item[Document] Hierbij wordt ieder stukje data, neem nu bijvoorbeeld 
een student, voorgesteld als een document. In dit document zit dan alle 
data vervat die een student moet voorstellen.
\item[Key-value]
\item[Graph]

\end{description}

MongoDB zelf valt onder de "document oriented" databanken. Hierbij wordt er niet uitgegaan van tabellen, maar van collecties. Een collectie kan bijvoorbeeld een verzameling klanten zijn. Iedere klant in de collectie wordt op zijn beurt voorgesteld als een document. Een document wordt voorgesteld als een JSONObject dat velden bezit. Die velden op hun beurt waarden. Als men SQL zou vergelijken met Mongo zou men de volgende tabel bekomen.

\begin{tabular}{lcr}
\hline
\head{Begrip} & \head{SQL} & \head{Mongo} \\
\hline
Verzameling & Tabel & Collection \\
Element van deze verzameling & Row & Document \\
Een attribuut van een element & column & field

\end{tabular}

Men kan in Mongo, net zoals in SQL, reffereren naar andere documenten. Wanneer er een nieuw document wordt aangemaakt wordt deze hetzij impliciet, hetzij expliciet voorzien van een ID. Dit ID kan als waarde voorkomen de velden van andere documenten. Men moet bij deze methode op enkele dingen letten. MongoDB is zo simpel mogelijk ontworpen en legt zelf heel weinig ristricties op. Alle validatie van data wordt overgelaten aan de applicatie. MongoDB gaat onder meer geen types opleggen aan de velden van een document. Ieder veld kan ieder type bevatten dat Mongo ondersteunt. Dit wilt zeggen dat een veld genaamd datum niet zozeer een datum hoeft te bevatten en dat ook andere objecten met hetzelfde veld iets anders kunnen bevatten dan een datum. Ook het aantal velden wordt op databankniveau niet opgelegd. Het ene document van een collectie kan 10 velden bevatten en het andere 20.

\subsubsection{Express}
Express is een bibliotheek die het maken van webapplicaties met nodejs vergemakkelijkt. Het vormt een extra laag bovenop nodejs. Het ondersteunt verschillende features. De feature waar wij het meest gebruik van gaan maken is de routing feature. Dit laat ons toe om routes te maken. Dit wil zeggen dat men een bepaalde url gaat koppelen aan een functie in JavaScript. Wanneer er dan naar deze url gesurft wordt, wordt deze functie uitgevoerd. Meestal worden er dan dingen uit de databank opgehaald naargelang de parameters die bij het request worden meegegeven. Daarna sturen we dat resultaat terug als een JSON Object

\subsubsection{Angular}

\subsection{RESTAPI} %hier heb ik wikipedia als bron gebruikt
Hier bespreken wij de RESTAPI
Wij gaan voor deze applicatie gebruik maken van een RESTFUL api. Dit zorgt
ervoor dat we makkelijk meerdere clents kunnen maken die ook op op desktops
werken, telefoons, misschien zelfs een tv. De mogelijkheden zijn nagenoeg
eindeloos.

RestApi's worden doorgaans gebruikt voor het ophalen en het wegschrijven van
data. Deze data kunnen uiteenlopende dingen zijn. Afbeeldingen, blogartikels,
zelfs volledige objecten. Deze RestApi is meestal toegankelijk via het HTTP
protocol. Dit zorgt ervoor dat het makkelijker is om clients te maken die deze
API kunnen gebruiken omdat HTTP een alomvertegenwoordigd protocol heeft. Het is
een protocol dat standaard in praktisch iedere networking api geïmplementeerd is
en dat als dus danig door vele computers begrepen wordt.

Elk type data (of resource) wordt voorgesteld door een uniform resource
identifier (ofwel URI)

Een RESTApi bestaat uit de volgende componenten.
\begin{description}
  \item [Get] Een get request
  \item [Delete] Verwijder data
  \item [Put] Verander data
  \item [Post] Bewaar data
\end{description}

\subsubsection{Beveiliging}
Het hebben van een goede applicatie betekent niet alleen dat de applicatie er goed uit moet zien. Klanten vertrouwen ons hun gegevens toe. Daarom moeten we erop toezien dat de applicatie goed beveiligd is. Dit hoop ik te bereiken door het gebruik van token based authenticatie. Wanneer een gebruiker zich aanmeldt zouden we alle gebruikers kunnen opsturen. Inclusief het wachtwoord. Wanneer de gebruiker dan data wilt opvragen zou deze terug zijn wachtwoord kunnen opsturen om zijn aanvraag te doen gelden. Dit gaan we echter niet doen. In plaats daarvan gaan we iedere gebruiker een token geven. De bedoeling is dat deze token opgestuurd zal worden in plaats van het wachtwoord. De tokens worden opgeslagen in een aparte collectie tezamen met de een veld waarin de datum staat wanneer de token is gemaakt. Telkens wanneer er een aanvraag afgehandeld wordt, wordt de token meegegeven via de query parameters. Dit wil zeggen de GET paramters. Hierna wordt er naar deze token gezocht. Als deze token bestaat, wordt er gekeken naar de leeftijd van de token. Mocht deze ouder zijn dan zeven dagen wordt er een foutboodschap teruggestuurd. Is dit niet het geval, dan is de aanvraag geautoriseerd en ontvangt de gebruiker zijn gevraagde gegevens. Mocht de token helemaal niet bestaan wordt er tevens een foutboodschap teruggestuurd. Telkens wanneer de token niet bestaat of deze vervallen is dient te gebruiker een nieuwe te genereren door zich opnieuw aan te melden.

\subsection{Tests}
De reliability van de applicatie cruciaal. Het gaat hier immers om een webapplictatie. De applicatie moet erop gebouwd zijn dat deze redelijk veel requests kan ontvangen en vooral, mochten deze requests fout opgesteld zijn, dat de applicatie deze opvangt en afhandelt zonder zelf te crashen. We zouden dit kunnen testen door zelf via de front-end foute data in te voeren, maar dit is onpraktisch. De applicatie is er immers op gebouwd om nooit foute data door te geven. Iedere data die ingevoerd wordt, wordt gevalideerd. Dit wilt echter niet zeggen dat de back-end de data ook goed valideert. In de wereld van JavaScript bestaan er hiervoor vele tools.

\subsection{AngularJS}
Voor dit project gaan we gebruik maken van AngularJS. Dit is een javascript framework bedoeld voor het vergemakkelijken van een Model View Controller webapplicatie. In tegenstelling tot vele andere model-view-controller frameworks voor webapplicaties, is AngularJS volledig geschreven in JavaScript. Dit heeft tot gevolg dat de applicatie volledig client-side kan werken. Dit heeft dan weer het voordeel dat de applicatie veel sneller zal draaien omdat er minder requests nodig zijn naar de server. Het Angular framework is volledig modulair opgebouwd. Een Angular applicatie bestaat typisch uit enkele modules. Deze modules kunnen verspreid zijn over meerdere bestanden. Wanneer men een applicatie opstart moet men meegeven welke moduels de applicatie precies gebruikt. Dit gebeurd als volgt.

\begin{verbatim}
var var seanclogApp = angular.module('seanclogApp',
		['seanClogServices', 'seanClogControllers', 'ngRoute', 'ui.grid',
		 'pascalprecht.translate']);
\end{verbatim}

Zoals u zelf waarschijnlijk zult merken is de applicatie zelf ook een module. Dit module systeem heeft zijn voordelen. Stel dat men de controllers van een de ene applicatie wilt gebruiken in een andere. Dan hoeft men enkel het bestand dat deze module bevat te kopiëren naar de broncode van de andere applicatie. Als dat gedaan is en het bronbestand geladen wordt door één van de webpagina's van uw applicatie moet men deze module registreren door deze aan de applicatie toe te voegen. Dit gaat als volgt.

\begin{verbatim}
var var seanclogApp = angular.module('seanclogApp',
		['seanClogServices', 'seanClogControllers', 'ngRoute', 'ui.grid',
		 'pascalprecht.translate', 'mijnNieuweModule']);
\end{verbatim}

In dit voorbeeld staat "mijnNiueweModule" voor de module die u zopas heeft toegevoegd.

\subsubsection{Views}
Omdat deze applicatie het model view controller design pattern gaat volgen gaan we ook gebruik maken van views. Deze views worden beheerd door AngularJS. Wanneer de gebruiker naar de root van onze applicatie navigeert (dit wil zeggen http://mydomain.com/) levert de applicatie zoals gewoonlijk een html pagina geleverd genaamd "index.html". Dit is echter meteen de enige echte webpagina die de gebruiker zal ontvangen. De rest zit vervat in code die samen verzonden wordt met de webpagina. Deze code beslist welke views er op welk moment getoond moeten worden.

Deze pagina ziet er als volgt uit
%FIXME: Ik gebruik hier geen tags, maar attributen
\begin{lstlisting}[language=html]
<html>
	<head>
		<!-- hier zetten we alle scripts die nodig zijn voor het draaien van de applicatie -->
	</head>
	<body>
		<div ng-view> <!-- hier komen de views --></div>
	</body>
</html>
\end{lstlisting}
Deze views zijn niets meer dan gewone webpagina's die tussen de broncode geworpen worden, op de plek waar de ngview tag staat. Deze code wordt dan in zijn geheel verwerkt door de webbrowser. De views kunnen bestaan uit één of meerdere subviews. Deze subviews kunnen worden toegevoegd door het gebruik van de ng-include tag. Stel dat men de volgende view heeft:
\begin{verbatim}
<div id="myview">
<p>Dit is een test</p>
</div>
\end{verbatim}
Dan zou men hier code uit een ander bestand er aan kunnen toevoegen.
\begin{verbatim}
<div id="myview">
<p>Dit is een test</p>
<div ng-include="'/partials/view2'"
</div>
\end{verbatim}

\subsubsection{Controllers}
%hier schrijven over het opsplitsen van de controllers
%Iedere resource heeft zijn eigen controller en door middel van het angular modulesysteem zetten we iedere
%controller in een eigen bestand. Op die manier blijft onze code ordelijk.

Wat betreft de controllers heb ik besloten om volledig gebruik te maken van Angulars kracht. Het modulaire systeem van AngularJS staat de programmeur toe om het programma in meerdere bestanden op te splitsen zolang men deze javascripts maar laad in de applicatie. Dit rekeninghoudend met de afhankelijkheid tussen de modules onderling.

Ik heb ervoor gekozen om voor iedere resource een controller te voorzien. Dit is in de meeste gevallen de aangewezen methode bij het maken van applicaties in het Model View controller patroon %Leg uit wat model view controller is.
Dit wil zeggen dat mochten we een resource genaamd klanten hebben, ik de applicatie ga voorzien van een controller genaamd klanten waarin alle procedures voor het afhandelen van informatie omtrent klanten, in zit vervat.  Dit gaat onder meer over bewerken, verwijderen, maken, plus nog enkele mogelijke hulpfuncties.

\subsubsection{Services}
Het ophalen van data van de database door de client gebeurt door middel van services. Services zijn een concept binnen AngularJS en kunnen gezien worden als singletons. Een service wordt gemaakt door de factory methode op te roepen van de het applicatieobject. Dit krijg twee parameters mee. De eerste parameter is een naam. Deze naam zal later gebruikt worden om naar onze service te kunnen refereren. De tweede parameter is een functie die een object hoort terug te geven. Dit object kan allerlei dingen bevatten. Variabelen, functies, het is kortom een volwaardig object. De bedoeling is dat dit object vanaf elke plek binnen onze applicatie beschikbaar zal zijn. We kunnen deze services in andere modules gebruiken. Bij het maken van een module moet er namelijk een array doorgegeven worden. Deze array is een lijst met strings. Deze strings zijn namen van services. Zo weet angular welke services in een module worden gebruikt. De genoemde services moeten daarna enkel als parameter genoemd worden in de functie gekoppeld aan de module. Daarbij zijn ze ook nog eens lui geïnitialiseerd. Dit wil zeggen dat Angular deze objecten enkel aanmaakt wanneer ze echt worden gebruikt. Men kan bijvoorbeeld een module laden waarin een service vervat zit, maar waarvan geen gebruik gemaakt wordt. Mocht deze service toch geïnitialiseerd worden, neemt deze onnodig plek in het geheugen en kan deze de applicatie nodeloos vertragen. Door deze techniek kan Angular sneller werken en hebben Angular applicaties een lagere memory-footprint.

\begin{verbatim}
Hier voorbeeldcode toevoegen
\end{verbatim}

\subsubsection{Filters}
%Hier schrijven over de datumfilter die ik heb gemaakt.

\subsubsection{Directives}

\subsubsection{Data validatie}
%Nagaan of de required direcitve wel degelijk iets van angular is
Men kan er niet altijd op vertrouwen dat de gebruiker de data op de juiste manier invoert. Om er zeker van te zijn dat er valide gegegevens ingegeven worden in de formulieren gaan we de gebruiker hier dus in bijstaan en validatie toepasssen. AngularJS heeft hiervoor enkele systemen ingebouwd. Het is mogelijk om binnen een formulier, velden aan te duiden die noodzakelijk zijn. Stel dat men bijvoorbeeld een klant wilt aanmaken. Dan heeft die klant een naam nodig. We kunnen die als volgt adwingen
\begin{lstlisting}[language=html]
<input type="text" ng-model="klant.naam" class="form-control" required />
\end{lstlisting}

We kunnen ook een bepaald type invoer afdwingen. We kunnen ervoor zorgen dat de gebruiker enkel nummers kan invoeren. Dit doen we door het type-attribuut van text naan number te veranderen.

Wanneer een invoerveld binnen een formulier niet geldig blijkt te zijn, zal Angular dit invoerveld toewijzen aan de klasse "ng-invalid". Als programmeur kan ik dan op deze klasse enkele stijlen toepassen die er bijvoorbeeld voor zorgen dat niet geldige invoervelden rood kleuren. Hetzelfde gebeurd met geldige invoervelden door middel van de "ng-valid" klasse. Verder krijgt een formulier in AngularJS een aantal extra objecten mee. Eén van die objecten is een object genaamd \$error. Dit object bevat informatie over welke invoervelden er op dat moment geldig zijn en welke niet. Stel dat men een invoerveld heeft met de naam "email". Wanneer dit invoerveld de text "blahblah" bevat zal het object "myform.email.\$error.eamil" de waarde true bevatten.

\section{vormgeving}

%Ik moet hier meer informatie over opzoeken
\subsection{Bootstrap}
Zelf ben ik niet zo een goede designer. Daarom heb ik besloten om deze klus uit te besteden aan een voorgekauwde collectie van CSS templates beter bekend als Bootstrap. Boostrap word meestal gebruikt om er zeker van te zijn dat de uiteindelijke website cross-browser zal werken. Op dit moment werkt Bootstrap op zowat alle moderne browsers. Deze templates zijn ook zodanig gemaakt dat de layout zich gemakkelijk aanpast aan verschillende grootten van schermen. Hete ondersteunt verschillende complexe layouts. Men kan er bijvoorbeeld voor zorgen dat de widgets automatisch in rijen staan en de breedte van het browserscherm gelijkmatig verdeeld wordt tussen de widgets.

\section{handleiding}


\end{document}
