%resumé pour le project seanclog
%Auteur: Pieter Van Keymeulen
%Titre: Seanclog: Simple and Fancy timetracker

\documentclass[a4paper,11pt]{article}
\usepackage{listings}

%Een commando voor een mooie tabelhoofding
\newcommand{\head}[1]{\textnormal{\textbf{#1}}}

\begin{document}
\title{Seanclog: Simple and Fancy timetracker}
\author{Pieter Van Keymeulen}
\maketitle

\section{Inleiding}

\subsection{Tijd. Planning. Al het andere}
Dit project heeft zijn oorsprong in mijn eigen persoonlijkheid. Als je het mijn
vrienden zou vragen of ik een ordelijke planner ben, zouden die allemaal
éénzelfde antwoord geven. Een gezamenlijk neen. Omdat ik er vrijwel continu aan
herinnerd wordt, wou ik dit probleem aanpakken. Ik ben programmeur, en het
typische aan dit beroep is dat men ordelijk moet kunnen plannen. Een knelpuntje
voor mij dus. Ik kreeg vaak veel software toegewezen om mij hierbij te helpen.
Veel van deze software ben ik uiteindelijk beginnen gebruiken. Soms hou ik van
deze software, en soms haat ik deze software. Bij de software die ik haat heb
ik, als programmeur, altijd de neiging om deze te willen verbeteren.

Hierbij begon ik een specifieke haat te ontwikkelen voor timetrackers

\subsection{Het probleem?}
Een programmeur wilt natuurlijk op tijd betaald worden. De programmeur wordt
gehuurd, krijgt een opdracht, wordt betaald voor de gepresteerde uren. Maar hoe
moet je nu zo een factuur opstellen. Hoe weet een programmeur nu hoe lang hij
voor een bepaald project heeft gewerkt en nog belangrijker, hoe weet de klant
dat hij een goede, eerlijke prijs betaald voor de afgeleverde software? Je kan
uren spenderen aan het invullen van spreadsheets. Die naar uw klanten sturen.
Verwachten dat uw klant deze zal opmerken. Dat terwijl de klant in kwestie zelf
onder honderden mails bedolven zit en uw mail niet eens opmerkt.

\subsection{Het licht gezien!}
Na heel lang zoeken heb ik uiteindelijk de oplossing gevonden. Wanneer er geen
enkele goede oplossing ter beschikking staat rest de meesten slechts één ding.
Maak het zelf. Met dit project heb ik het doel om een timetracker te maken die
alle eigenschappen die ik aan timetrackers haat niet heeft. Hoofdzakelijk houdt
dit het volgende in.
\begin{itemize}
  \item Minder manueel invoeren
  \item Offline toegang
  \item Toegang vanop meerdere apparaten
  \item Een interface met zo weinig mogelijk afleiding
  \item Gemakkelijke filtering van ingevoerde tracks
\end{itemize}

\section{Interne structuur}

\subsection{Gebruikte software}
Voor dit project werd er bijna uitsluitend gebruik gemaakt van experimentele
technologie. Tegenwoordig worden webapplicaties vaak ontwikkeld op de zogenaamde
LAMP stack. Dit is een collectie software die meestal gebundeld gedistribueerd
wordt omdat ze tezamen de gebruiker in staat stellen tot het hosten van een
webapplicatie. De LAMP stack bestaat uit vier onderdelen.

\begin{description}
\item[Een Linux server] Dit is het besturingssysteem waarop de applicatie zal
draaien
\item[Apache] Dit is een daemon die het http protocol implementeert. Het stelt
ons in staat tot het ontvangen en het verwerken van http requests.
\item[Een MYSQL databank] Dit is te gebruiken databank bedoeld voor het oplaan
van data. Dit kan gaan om klantengegevens en productgegevens. Andere databanken
zoals postgresql zijn ook mogelijk, maar bij een LAMP stack gaat het specifiek
om MYSQL.
\item[PHP] De programmeertaal die gebruikt wordt voor het maken van de
applicatie.
\end{description}

Deze LAMP stack wordt al jaren op deze manier gebruikt. Het is vrij oude
technologie die al jaren meegaat en bijgevolg dus enorm betrouwbaar is. Het
heeft echter een aantal zwakke punten.

\begin{itemize}
  \item Het onderhoud van een linux server is een tijdrovende bezigheid.
  \item Apache is een modulair programma. Men kan functionaliteit toevoegen en
  verwijderen. Veel van de functionaliteit staat standaard aan of kan zelfs
  helemaal niet verwijderd worden. Dat terwijl de meesten niet zoveel
  functionaliteit nodig hebben. Daarbij kan het ook ervoor zorgen dat Apache
  onveiliger wordt en gemakkelijker is om in in te breken.
  \item MYSQL heeft veel limitaties. We leven in een wereld waarin data alsmaar
  meer aandacht krijgt. Bedrijven verzamelen, analyseren en gebruiken. Dit
  allemaal om hun klantenervaring zo veel mogelijk te kunnen verbeteren.
\end{itemize}

\subsubsection{Nodejs}
Nodejs is een javascript interpreter die in tegenstelling tot andere javascript interpreters niet gekoppeld is aan een webbrowser. Men kan hiermee javascripts uitvoeren alsof het gewone programma's zouden zijn. Dit heeft als neveneffect dat het ook gebruikt kan worden voor bijvoorbeeld server side scripting.

Dit is echter slecht één van de redenen waarom het een handige tool is voor het gebruik bij server side scripting. Tegenwoordig worden er alsmaar meer webapplicaties gebouwd. De bedrijven die deze webapplicaties bouwen hebben alsmaar meer klanten. Al die klanten moeten tegelijk afgehandeld worden. Computers hebben echter hun limieten. Wanneer een gebruiker een webpagina zou opvragen, betekend dat dat deze gebruiker een html bestand doorgestuurd zal moeten krijgen. Dat HTML bestand dient ingelezen en doorgestuurd te worden. Wanneer het besturingssysteem een bestand inleest betekent dat dat deze een zogezegde lock op dat bestand legt. Enkel het proces dat de leesbewerking heeft aangevraagd, mag het bestand inlezen. Van zodra dit proces gedaan heeft met lezen, wordt deze lock vrijgegeven en is het de beurt aan het volgende proces.

\subsubsection{MongoDB}
MongoDB is, in tegenstelling tot traditionele SQL databanken, een 
no-sql databank. Dit wil zeggen dat de data niet voorgesteld wordt door 
tabellen. Hoe de data dan wel voorgesteld wordt, wordt in de definitie 
van no-sql niet vervat. Over het algemeen wordt bij een gewone mysql 
databank, een collectie aan data voorgesteld door een tabel. Bij een 
nosql gaat men uit van andere metaforen die ieder beter bij het 
werkveld passen waarvoor de databank specifiek ontworpen is. Stel nu 
dat ik een complexe hiërarchie binnen een bedrijf als gegeven heb. 
Iedere werknemer van dit bedrijf heeft contacten, die op hun beurt 
contacten hebben, die op hun beurt alweer contacten hebben. Dan zou 
het leuk zijn mocht ik al de relaties die deze werknemers met elkaar 
hebben op een efficiënte manier kunnen ophalen. Wanneer men vasthoudt 
aan de klassieke tabel metafoor is dit echter heel moeilijk, maar 
wanneer we de relaties op één of andere manier op voorhand in de data 
kunnen programmeren, dan wordt het ineens een stuk makkelijker.
dat ik  Over het algemeen kan men spreken over de 
volgende types nosql databanken

\begin{description}

\item[Column]
\item[Document] Hierbij wordt ieder stukje data, neem nu bijvoorbeeld 
een student, voorgesteld als een document. In dit document zit dan alle 
data vervat die een student moet voorstellen.
\item[Key-value]
\item[Graph]

\end{description}

MongoDB zelf valt onder de "document oriented" databanken. Hierbij wordt er niet uitgegaan van tabellen, maar van collecties. Een collectie kan bijvoorbeeld een verzameling klanten zijn. Iedere klant in de collectie wordt op zijn beurt voorgesteld als een document. Een document wordt voorgesteld als een JSONObject dat velden bezit. Die velden op hun beurt waarden. Als men SQL zou vergelijken met Mongo zou men de volgende tabel bekomen.

\begin{tabular}{lcr}
\hline
\head{Begrip} & \head{SQL} & \head{Mongo} \\
\hline
Verzameling & Tabel & Collection \\
Element van deze verzameling & Row & Document \\
Een attribuut van een element & column & field

\end{tabular}


\subsubsection{Express}
Express is een bibliotheek die het maken van webapplicaties met nodejs vergemakkelijkt. Het vormt een extra laag bovenop nodejs. Het ondersteunt verschillende features. De feature waar wij het meest gebruik van gaan maken is de routing feature. Dit laat ons toe om routes te maken. Dit wil zeggen dat men een bepaalde url gaat koppelen aan een functie in JavaScript. Wanneer er dan naar deze url gesurft wordt, wordt deze functie uitgevoerd. Meestal worden er dan dingen uit de databank opgehaald naargelang de parameters die bij het request worden meegegeven. Daarna sturen we dat resultaat terug als een JSON Object

\subsubsection{Angular}

\subsection{RESTAPI} %hier heb ik wikipedia als bron gebruikt
Hier bespreken wij de RESTAPI
Wij gaan voor deze applicatie gebruik maken van een RESTFUL api. Dit zorgt
ervoor dat we makkelijk meerdere clients kunnen maken die ook op op desktops
werken, telefoons, misschien zelfs een tv. De mogelijkheden zijn nagenoeg
eindeloos.

RestApi's worden doorgaans gebruikt voor het ophalen en het wegschrijven van
data. Deze data kunnen uiteenlopende dingen zijn. Afbeeldingen, blogartikels,
zelfs volledige objecten. Deze RestApi is meestal toegankelijk via het HTTP
protocol. Dit zorgt ervoor dat het makkelijker is om clients te maken die deze
API kunnen gebruiken omdat HTTP een alomvertegenwoordigd protocol heeft. Het is
een protocol dat standaard in praktisch iedere networking api geïmplementeerd is
en dat als dus danig door vele computers begrepen wordt.

Elk type data (of resource) wordt voorgesteld door een uniform resource
identifier (ofwel URI)

Een RESTApi bestaat uit de volgende componenten.
\begin{description}
  \item [Get] Een get request
  \item [Delete] Verwijder data
  \item [Put] Verander data
  \item [Post] Bewaar data
\end{description}

\subsection{AngularJS}
Voor dit project gaan we gebruik maken van AngularJS. Dit is een javasript framework bedoeld voor het vergemakkelijken van een Model View Controller webapplicatie. In tegenstelling tot vele andere model-view-controller frameworks voor webapplicaties, is AngularJS volledig geschreven in JavaScript. Dit heeft tot gevolg dat de applicatie volledig client-side kan werken. Dit heeft dan weer het voordeel dat de applicatie veel sneller zal draaien omdat er minder requests nodig zijn naar de server. Het Angular framework is volledig modulair opgebouwd. Een Angular applicatie bestaat typisch uit enkele modules. Deze modules kunnen verspreid zijn over meerdere bestanden. Wanneer men een applicatie opstart moet men meegeven welke moduels de applicatie precies gebruikt. Dit gebeurd als volgt.

\begin{verbatim}
var var seanclogApp = angular.module('seanclogApp',
		['seanClogServices', 'seanClogControllers', 'ngRoute', 'ui.grid',
		 'pascalprecht.translate']);
\end{verbatim}

Zoals u zelf waarschijnlijk zult merken is de applicatie zelf ook een module. Dit module systeem heeft zijn voordelen. Stel dat men de controllers van een de ene applicatie wilt gebruiken in een andere. Dan hoeft men enkel het bestand dat deze module bevat te kopiëren naar de broncode van de andere applicatei. Als dat gedaan is en het bronbestand geladen wordt door één van de webpagina's van uw applicatie moet men deze module registreren door deze aan de applicatie toe te voegen. Dit gaat als volgt.

\begin{verbatim}
var var seanclogApp = angular.module('seanclogApp',
		['seanClogServices', 'seanClogControllers', 'ngRoute', 'ui.grid',
		 'pascalprecht.translate', 'mijnNieuweModule']);
\end{verbatim}

In dit voorbeeld staat "mijnNiueweModule" voor de module die u zopas heeft toegevoegd.

\subsubsection{Views}
Omdat deze applicatie het model view controller design pattern gaat volgen gaan we ook gebruik maken van views. Deze views worden beheerd door AngularJS. Wanneer de gebruiker naar de root van onze applicatie navigeert (dit wil zeggen http://mydomain.com/) levert de applicatie zoals gewoonlijk een html pagina geleverd genaamd "index.html". Dit is echter meteen de enige echte webpagina die de gebruiker zal ontvangen. De rest zit vervat in code die samen verzonden wordt met de webpagina. Deze code beslist welke views er op welk moment getoond moeten worden.

Deze pagina ziet er als volgt uit
%FIXME: Ik gebruik hier geen tags, maar attributen
\begin{lstlisting}[language=html]
<html>
	<head>
		<!-- hier zetten we alle scripts die nodig zijn voor het draaien van de applicatie -->
	</head>
	<body>
		<div ng-view> <!-- hier komen de views --></div>
	</body>
</html>
\end{lstlisting}
Deze views zijn niets meer dan gewone webpagina's die tussen de broncode geworpen worden, op de plek waar de ngview tag staat. Deze code wordt dan in zijn geheel verwerkt door de webbrowser. De views kunnen bestaan uit één of meerdere subviews. Deze subviews kunnen worden toegevoegd door het gebruik van de ng-include tag. Stel dat men de volgende view heeft:
\begin{verbatim}
<div id="myview">
<p>Dit is een test</p>
</div>
\end{verbatim}
Dan zou men hier code uit een ander bestand er aan kunnen toevoegen.
\begin{verbatim}
<div id="myview">
<p>Dit is een test</p>
<div ng-include="'/partials/view2'"
</div>
\end{verbatim}

\subsubsection{Controllers}

\subsubsection{Services}
Het ophalen van data van de database door de client gebeurt door middel van services. Services zijn een concept binnen AngularJS en kunnen gezien worden als singletons. Een service wordt gemaakt door de factory methode op te roepen van de het applicatieobject. Dit krijg twee parameters mee. De eerste parameter is een naam. Deze naam zal later gebruikt worden om naar onze service te kunnen refereren. De tweede parameter is een functie die een object hoort terug te geven. Dit object kan allerlei dingen bevatten. Variabelen, functies, het is kortom een volwaardig object. De bedoeling is dat dit object vanaf elke plek binnen onze applicatie beschikbaar zal zijn. We kunnen deze services in andere modules gebruiken. Bij het maken van een module moet er namelijk een array doorgegeven worden. Deze array is een lijst met strings. Deze strings zijn namen van services. Zo weet angular welke services in een module worden gebruikt. De genoemde services moeten daarna enkel als parameter genoemd worden in de functie gekoppeld aan de module.

\begin{verbatim}
Hier voorbeeldcode toevoegen
\end{verbatim}

\subsubsection{Filters}

\section{vormgeving}

%dit moet ik nog in subsecties opdelen


\section{handleiding}


\end{document}
