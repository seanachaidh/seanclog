%resumé pour le project seanclog
%Auteur: Pieter Van Keymeulen
%Titre: Seanclog: Simple and Fancy timetracker

\documentclass[a4paper,11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[dutch]{babel}
\usepackage{listings}
\usepackage{color}
\usepackage{graphicx}
\usepackage{placeins}
\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstdefinelanguage{CSS}{
morekeywords={accelerator,azimuth,background,background-attachment,
background-color,background-image,background-position,
background-position-x,background-position-y,background-repeat,
behavior,border,border-bottom,border-bottom-color,
border-bottom-style,border-bottom-width,border-collapse,
border-color,border-left,border-left-color,border-left-style,
border-left-width,border-right,border-right-color,
border-right-style,border-right-width,border-spacing,
border-style,border-top,border-top-color,border-top-style,
border-top-width,border-width,bottom,caption-side,clear,
clip,color,content,counter-increment,counter-reset,cue,
cue-after,cue-before,cursor,direction,display,elevation,
empty-cells,filter,float,font,font-family,font-size,
font-size-adjust,font-stretch,font-style,font-variant,
font-weight,height,ime-mode,include-source,
layer-background-color,layer-background-image,layout-flow,
layout-grid,layout-grid-char,layout-grid-char-spacing,
layout-grid-line,layout-grid-mode,layout-grid-type,left,
letter-spacing,line-break,line-height,list-style,
list-style-image,list-style-position,list-style-type,margin,
margin-bottom,margin-left,margin-right,margin-top,
marker-offset,marks,max-height,max-width,min-height,
min-width,-moz-binding,-moz-border-radius,
-moz-border-radius-topleft,-moz-border-radius-topright,
-moz-border-radius-bottomright,-moz-border-radius-bottomleft,
-moz-border-top-colors,-moz-border-right-colors,
-moz-border-bottom-colors,-moz-border-left-colors,-moz-opacity,
-moz-outline,-moz-outline-color,-moz-outline-style,
-moz-outline-width,-moz-user-focus,-moz-user-input,
-moz-user-modify,-moz-user-select,orphans,outline,
outline-color,outline-style,outline-width,overflow,
overflow-X,overflow-Y,padding,padding-bottom,padding-left,
padding-right,padding-top,page,page-break-after,
page-break-before,page-break-inside,pause,pause-after,
pause-before,pitch,pitch-range,play-during,position,quotes,
-replace,richness,right,ruby-align,ruby-overhang,
ruby-position,-set-link-source,size,speak,speak-header,
speak-numeral,speak-punctuation,speech-rate,stress,
scrollbar-arrow-color,scrollbar-base-color,
scrollbar-dark-shadow-color,scrollbar-face-color,
scrollbar-highlight-color,scrollbar-shadow-color,
scrollbar-3d-light-color,scrollbar-track-color,table-layout,
text-align,text-align-last,text-decoration,text-indent,
text-justify,text-overflow,text-shadow,text-transform,
text-autospace,text-kashida-space,text-underline-position,top,
unicode-bidi,-use-link-source,vertical-align,visibility,
voice-family,volume,white-space,widows,width,word-break,
word-spacing,word-wrap,writing-mode,z-index,zoom},
morestring=[s]{:}{;},
sensitive,
morecomment=[s]{/*}{*/}
}

\lstset{
   language=JavaScript,
   backgroundcolor=\color{lightgray},
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
   numbers=left,
   numberstyle=\footnotesize,
   numbersep=9pt,
   tabsize=2,
   breaklines=true,
   showtabs=false,
   captionpos=b
}
%Een commando voor een mooie tabelhoofding
\newcommand{\head}[1]{\textnormal{\textbf{#1}}}

\begin{document}
\title{Seanclog: Simple and Fancy timetracker}
\author{Pieter Van Keymeulen}
\maketitle
\section{Inleiding}

\subsection{Tijd. Planning. Al het andere}
Dit project heeft zijn oorsprong in mijn eigen persoonlijkheid. Als je het mijn
vrienden zou vragen of ik een ordelijke planner ben, zouden die allemaal
éénzelfde antwoord geven. Een gezamenlijk neen. Omdat ik er vrijwel continu aan
herinnerd wordt, wou ik dit probleem aanpakken. Ik ben programmeur, en het
typische aan dit beroep is dat men ordelijk moet kunnen plannen. Een knelpuntje
voor mij dus. Ik kreeg vaak veel software toegewezen om mij hierbij te helpen.
Veel van deze software ben ik uiteindelijk beginnen gebruiken. Soms hou ik van
deze software, en soms haat ik deze software. Bij de software die ik haat heb
ik, als programmeur, altijd de neiging om deze te willen verbeteren.

Hierbij begon ik een specifieke haat te ontwikkelen voor timetrackers

\subsection{Het probleem?}
Een programmeur wilt natuurlijk op tijd betaald worden. De programmeur wordt
gehuurd, krijgt een opdracht, wordt betaald voor de gepresteerde uren. Maar hoe
moet je nu zo een factuur opstellen. Hoe weet een programmeur nu hoe lang hij
voor een bepaald project heeft gewerkt en nog belangrijker, hoe weet de klant
dat hij een goede, eerlijke prijs betaald voor de afgeleverde software? Je kan
uren spenderen aan het invullen van spreadsheets. Die naar uw klanten sturen.
Verwachten dat uw klant deze zal opmerken. Dat terwijl de klant in kwestie zelf
onder honderden mails bedolven zit en uw mail niet eens opmerkt.

\subsection{Het licht gezien!}
Na heel lang zoeken heb ik uiteindelijk de oplossing gevonden. Wanneer er geen
enkele goede oplossing ter beschikking staat rest de meesten slechts één ding.
Maak het zelf. Met dit project heb ik het doel om een timetracker te maken die
alle eigenschappen die ik aan timetrackers haat niet heeft. Hoofdzakelijk houdt
dit het volgende in.
\begin{itemize}
  \item Minder manueel invoeren
  \item Offline toegang
  \item Toegang vanop meerdere apparaten
  \item Een interface met zo weinig mogelijk afleiding
  \item Gemakkelijke filtering van ingevoerde tracks
\end{itemize}
\section{Gebruikte software}
%Voor dit project werd er bijna uitsluitend gebruik gemaakt van experimentele
%technologie. Tegenwoordig worden webapplicaties vaak ontwikkeld op de zogenaamde
%LAMP stack. Dit is een collectie software die meestal gebundeld gedistribueerd
%wordt omdat ze tezamen de gebruiker in staat stellen tot het hosten van een
%webapplicatie. De LAMP stack bestaat uit vier onderdelen.
%
%\begin{description}
%\item[Een Linux server] Dit is het besturingssysteem waarop de applicatie zal
%draaien
%\item[Apache] Dit is een daemon die het http protocol implementeert. Het stelt
%ons in staat tot het ontvangen en het verwerken van http requests.
%\item[Een MYSQL databank] Dit is te gebruiken databank bedoeld voor het oplaan
%van data. Dit kan gaan om klantengegevens en productgegevens. Andere databanken
%zoals postgresql zijn ook mogelijk, maar bij een LAMP stack gaat het specifiek
%om MYSQL.
%\item[PHP] De programmeertaal die gebruikt wordt voor het maken van de
%applicatie.
%\end{description}
%
%Deze LAMP stack wordt al jaren op deze manier gebruikt. Het is vrij oude
%technologie die al jaren meegaat en bijgevolg dus enorm betrouwbaar is. Het
%heeft echter een aantal zwakke punten.
%
%\begin{itemize}
%  \item Het onderhoud van een linux server is een tijdrovende bezigheid.
%  \item Apache is een modulair programma. Men kan functionaliteit toevoegen en
%  verwijderen. Veel van de functionaliteit staat standaard aan of kan zelfs
%  helemaal niet verwijderd worden. Dat terwijl de meesten niet zoveel
%  functionaliteit nodig hebben. Daarbij kan het ook ervoor zorgen dat Apache
%  onveiliger wordt en gemakkelijker is om in in te breken.
%  \item MYSQL heeft veel limitaties. We leven in een wereld waarin data alsmaar
%  meer aandacht krijgt. Bedrijven verzamelen, analyseren en gebruiken. Dit
%  allemaal om hun klantenervaring zo veel mogelijk te kunnen verbeteren.
%\end{itemize}

Voor dit project wordt er gebruik gemaakt van de MEAN-stack. Dit is variant op de LAMP stack. De LAMP stack wordt tegenwoordig het meest gebruikt. De MEAN stack daarentegen is een vrij jong concept. Veeleer omdat de MEAN stack uitsluitend uit nieuwe technologie bestaat.

De MEAN stack is een collectie van software die er voor zorgt dat men de mogelijkheid heeft een webapplicatie te ontwikkelen. Deze MEAN stack bestaat uit de volgende onderdelen

\begin{description}
\item[MongoDB] Dit is een niet-relationele databank. In plaats van de data voor te stellen als relationele tabellen gaat men de data voorstellen als een collectie van documenten. Ieder document is een JSON object. JSON formaat dat dezelfde stijl als javascript gebruikt om objecten op te slaan.
\item[Express] Express is een nodejs framework waarmee makkelijk webapplicaties in nodejs kunnen worden gemaakt. Het voor ziet voornamelijk een manier om routes te programmeren binnen je applicatie alsook het toevoegen van middleware.
\item[AngularJS] AngularJS is een javascript framework die de gebruiker in staat stelt om via javascript client-side een MVC patroon toe te passen. Dit doen ze door het voorzien van controllers, views en services. Meer informatie hierover later
\item[NodeJS] Dit is een javascript interpreter die zonder browser werk. In plaats hiervan wordt de google V8 engine gebruikt om javascript code uit te voeren. Dit stelt ons in staat om javascript ook server side te gaan gebruiken. In tegenstelling tot veel andere programmeertalen, werkt file input/output volledig nog blocking. Hierdoor is het perfect voor het maken van webapplicaties omdat op die manier meerdere requests tegelijkertijd afgehandeld kunnen worden.

\end{description}

\subsection{Nodejs}
Nodejs is een javascript interpreter die in tegenstelling tot andere javascript interpreters niet gekoppeld is aan een webbrowser. Men kan hiermee javascripts uitvoeren alsof het gewone programma's zouden zijn. Dit heeft als neveneffect dat het ook gebruikt kan worden voor bijvoorbeeld server side scripting.\cite{NodeJS}

Eigenlijk is het ook niet correct om NodeJS een interpreter te noemen. NodeJS gebruikt immers google's v8 javascript engine. Waarin deze engine zich onderscheid van de andere engines is dat de code eerst wordt gecompileerd naar machinecode voor het wordt uitgevoerd. Hierdoor is er geen echt interpreting proces zoals bijvoorbeeld bij php het geval is.

Dit is echter slecht één van de redenen waarom het een handige tool is voor het gebruik bij server side scripting. Tegenwoordig worden er alsmaar meer webapplicaties gebouwd. De bedrijven die deze webapplicaties bouwen hebben alsmaar meer klanten. Al die klanten moeten tegelijk afgehandeld worden. Computers hebben echter hun limieten. Wanneer een gebruiker een webpagina zou opvragen, betekend dat dat deze gebruiker een html bestand doorgestuurd zal moeten krijgen. Dat HTML bestand dient ingelezen en doorgestuurd te worden. Wanneer het besturingssysteem een bestand inleest betekent dat dat deze een zogezegde lock op dat bestand legt. Enkel het proces dat de leesbewerking heeft aangevraagd, mag het bestand inlezen. Van zodra dit proces gedaan heeft met lezen, wordt deze lock vrijgegeven en is het de beurt aan het volgende proces. Wanneer één van de processen die aanspraak willen maken op het bestand, nadat hij deze aanspraak gekregen heeft, in een lus gaat. Vormt dit een dead-lock. Dit wil zeggen dat alle input en output met betrekking tot dit bestand stilvalt en niemand meer aan het bestand kan. Het hele proces valt stil.

In NodeJS zijn er echter geen locks. Bijna geen enkele functie binnen NodeJS voert directe input en output uit. NodeJS werkt volledig event driven. Waar bij andere talen event driven programming vaak gerealiseerd wordt via een extern framework en de gebruiker manueel een main event loop moet aanroepen is deze manier van programmeren een onderdeel van de taal zelf. NodeJS programma's worden vaak geprogrammeerd als een reeks van events. Het programma begint te draaien en registreert welke events er allemaal in het programma gedeclareerd zijn. Daarna wordt de main event loop automatisch opgebouwd en wordt er naar alle events gekeken. Wanneer NodeJS er zeker van is dat er geen enkel event meer afgevuurd zal worden, of wanneer de gebruiker het programma expliciet stop, wordt er uit de main event loop gesprongen en stopt het programma.

\subsection{Heroku}
Heroku is een bedrijf dat een PAAS dienst aanbiedt.\cite{wiki:heroku}. Ze bieden een volledig platform aan voor het hosten van webapplicaties. Standaard wordt een app gehost op een Ubuntu Linux. Deze Linux heeft geen andere voorzieningen. Die moet men bij het Heroku add-on center toevoegen. Vaak kosten deze toevoegingen geld. Heroku staat toe dat het gebruik van een postgresql databank gratis zolang de hoeveelheid data onder de tienduizend rijen blijft. Het is ook mogelijk om andere types databanken te gebruiken, zoals in dit geval MongoDB, maar hiervoor is men afhankelijk van add-ons van externe bedrijven. Bij het maken van van een app wordt deze in het begin gedraaid op één "dyno". Dit is heroku terminologie om te zeggen dat er één instantie van de applicatie draait. Men kan dit naar gelieve optrekken tot meerdere dyno's maar dat gaat geld kosten.

De kosten bij Heroku worden berekend per uur. Niet per maand, zoals dat bij traditionele webhosting het geval is. Wanneer de applicatie een uur niet draait wordt er voor dat uur niets aangerekend. Men zou dus in principe, als men geld zou willen besparen, de applicatie op bepaald momenten niet kunnen draaien. Bij Heroku is dit echter geen probleem want de eerste 750 dyno uren zijn gratis. Dit betekent dat men een  applicatie een maand lang gratis kan draaien zolang deze maar één dyno gebruikt. Stel dat men twee instanties van de applicatie zou willen draaien, dan zou men slechts voor een halve maand niet gefactureerd worden.

\subsection{MongoDB}
MongoDB is, in tegenstelling tot traditionele SQL databanken, een 
no-sql databank. Dit wil zeggen dat de data niet voorgesteld wordt door 
tabellen. Hoe de data dan wel voorgesteld wordt, wordt in de definitie 
van no-sql niet vervat. Over het algemeen wordt bij een gewone mysql 
databank, een collectie aan data voorgesteld door een tabel. Bij een 
nosql gaat men uit van andere metaforen die ieder beter bij het 
werkveld passen waarvoor de databank specifiek ontworpen is. Stel nu 
dat ik een complexe hiërarchie binnen een bedrijf als gegeven heb. 
Iedere werknemer van dit bedrijf heeft contacten, die op hun beurt 
contacten hebben, die op hun beurt alweer contacten hebben. Dan zou 
het leuk zijn mocht ik al de relaties die deze werknemers met elkaar 
hebben op een efficiënte manier kunnen ophalen. Wanneer men vasthoudt 
aan de klassieke tabel metafoor is dit echter heel moeilijk, maar 
wanneer we de relaties op één of andere manier op voorhand in de data 
kunnen programmeren, dan wordt het ineens een stuk makkelijker.
dat ik  Over het algemeen kan men spreken over de 
volgende types nosql databanken

\begin{description}

\item[Column] Hierbij wordt er bij het persisteren van data de nadruk geleld op de kolom in plaats van de rij. %Dit moet ik beter uitleggen
\item[Document] Hierbij wordt ieder stukje data, neem nu bijvoorbeeld 
een student, voorgesteld als een document. In dit document zit dan alle 
data vervat die een student moet voorstellen.
\item[Key-value] Hierbij wordt iedere waarde die geschreven wordt naar de databank voorgesteld door middel van een sleutel. Later kan in de applicatie naar die sleutel gerefereerd worden.
\item[Graph] Hierbij worden de gegevens voorgesteld door een graaf. Dit soort databank legt minder focus op de gegevens op zich, maar eerder op de relaties die de gegevens onderling hebben. %Hier een afbeelding van een graaf ingooien
\end{description}

Gezien dat er in deze applicatie eerder gebruik wordt gemaakt van een document-georiënteerde databank, gaat de focus van dit document hier voornamelijk naar uit. Zoals hierboven al is uitgelegd geweest stelt een document-georiënteerde databank, zoals MongoDB, de data voor als een collectie van documenten. Deze documenten kunnen in alle mogelijke vormen komen. XML, JSON, YAML, of zelfs gewoon een binaire blob. In wezen zou men zo document-georiënteerde databank in de vrij letterlijke zin kunnen gebruiken en er scans van bijvoorbeeld facturen in opslagen die dan verzameld worden in de collectie "facturen". In het geval van MongoDB worden documenten uitsluitend in het JSON format opgeslagen, of beter gezegd, BSON, wat MongoDB zijn eigen binaire variant is van JSON. Het gebruik van JSON heeft vele voordelen tegenover het gebruik van traditionele relationele tabellen.  Met JSON kan men immers een object nesten in ander object. Dit is vooral nuttig wanneer bepaalde gegevens altijd tezamen worden gebruikt. Stel nu dat men de gegevens van een werkgever zou bewaren. Dan wilt men meestal ook het adres van deze werknemer bewaren. Vanwege de enorme hoeveelheid kolommen dat adresgegevens gewoonlijk in beslag nemen, wordt dit meestal in een andere tabel gestoken. De persoonsgegevens en het gekoppelde adres worden echter altijd tezamen gebruikt, maar bij relationele systemen moet hier telkens een JOIN clausule worden gebruikt waar naar beide tabellen wordt gerefereerd om uiteindelijk de twee tabellen samen te voegen. Dit is enorm veel schrijfwerk. Zeker als die JOIN in tachtig procent van de gevallen gebruikt wordt.

In MongoDB kan men dit allemaal vermijden. Wanneer men een werknemer in de databank aanmaakt kan men in MongoDB het adres van die werknemer opslaan als een object dat een werknemer "bezit". Het uiteindelijke JSON-object is dan als volgt.

\begin{lstlisting}[language=javascript]
{
	naam: James bond,
	werknemerid: 007
	adres {
		straat: to expensive yacht,
		nummer: 666,
		city: caribbean sea
	}
};
\end{lstlisting}

Tegenwoordig wordt er nog steeds veelvuldig gebruik gemaakt van relationele databanken. Er is echter een grote verschuiving gaande ten voordele van de niet relationele databanken. Deze verschuiving is begrijpelijk omdat laatstgenoemde veel meer voorzien is op het verwerken van grote hoeveelheden data. Sinds vijf jaar geleden hebben sociale netwerken almaar meer belang gekregen in onze samenleving. Deze worden voor diverse dingen gebruikt. Foto's delen, documenten delen, ervaringen delen. Veel van deze applicaties bieden al deze diensten aan binnen één platform. Vroeger was het de gewoonte dat iemand een aparte provider gebruikte voor zijn email, om te chatten, om te bloggen, om foto's te delen. In de laatste vijf jaar is het internet echter meer gecentraliseerd geraakt waardoor één organisatie een enorme hoeveelheid data beheert. Neem daarbij dat we met almaar meer mensen op deze wereld leven die almaar vaker toegang hebben tot ICT en het plaatje is compleet.

Omdat relationele databanken nog steeds veel gebruikt worden is het handig om hier een analogie te scheppen tussen relationele databanken en MongoDB

\begin{tabular}{lcr}
\hline
\head{Begrip} & \head{Relationele databank} & \head{Mongo} \\
\hline
Verzameling & Tabel & Collection \\
Element van deze verzameling & Row & Document \\
Een attribuut van een element & column & field

\end{tabular}

Men kan in Mongo, net zoals in SQL, verwijzen naar andere documenten. Wanneer er een nieuw document wordt aangemaakt wordt deze hetzij impliciet, hetzij expliciet voorzien van een ID. Dit ID kan als waarde voorkomen de velden van andere documenten. Men moet bij deze methode op enkele dingen letten. MongoDB is zo simpel mogelijk ontworpen en legt zelf heel weinig restricties op. Alle validatie van data wordt overgelaten aan de applicatie. MongoDB gaat onder meer geen types opleggen aan de velden van een document. Ieder veld kan ieder type bevatten dat Mongo ondersteunt. Dit wilt zeggen dat een veld genaamd datum niet zozeer een datum hoeft te bevatten en dat ook andere objecten met hetzelfde veld iets anders kunnen bevatten dan een datum. Ook het aantal velden wordt op databankniveau niet opgelegd. Het ene document van een collectie kan 10 velden bevatten en het andere 20.

\subsubsection{Query's op MongoDB}


\subsubsection{GridFS}
Een extraatje van MongoDB waar in deze applicatie geen gebruik van wordt gemaakt heet GridFS. Eerder ging het erover dat bij een document-georiënteerde databank, een gegeven ieder type bestand kan zijn. Dit kan gaan om afbeeldingen, muziek, of, in het geval van Mongo, om JSON documenten. Documenten kunnen maximum 16MB groot zijn. Dus zelfs al zou men iets anders willen bewaren dan een JSON-object. Dan zou het nog niet lukken. Of niet? MongoDB heeft hier namelijk een oplossing voor, genaamd GridFS. GridFS laat toe om andere types documenten op te slaan in plaats van een JSON-objecten. Deze andere documenten kunnen eventueel alsnog vergezeld worden door enkele JSON gegevens. Dit komt omdat GridFS bedoeld is om documenten op te splitsen over meerdere collecties. Wanneer het document opgevraagd wordt, stel MongoDB het document opnieuw samen.

\subsubsection{Full text search}
MongoDB biedt de mogelijkheid voor het doorzoeken van text.\cite{mongodb:textindex} Dit gebeurt via tekstindexen. Een tekstindex kan gemaakt worden voor iedere veld waarvan de waarde een string is of waarvan de waarde een array van strings is. Het kan dus niet gebruikt worden op nummers. Om een query uit te voeren die gebruikt maakt van de tekstindex moet men gebruik maken van de \$text operator.

Om een tekstindex te maken moeten we de ensureIndex methode gebruiken. Deze functie krijgt het veld mee en de waarde "text" om aan te duiden dat het om een tekstindex gaat. Zie hier een voorbeeld:

\begin{lstlisting}
db.projecten.ensureIndex({titel: "text"})
\end{lstlisting}
Een collectie kan slechts één tekstindex hebben, maar die index kan wel uit meerdere velden bestaan. Dan gaat Mongo alle data in deze velden catalogiseren om te gebruiken bij het doorzoeken van de collectie. Let hierbij op dat bij het doorzoeken altijd rekening gehouden wordt met alle velden waaruit de tekstindex bestaat. Men kan dus niet alleen het veld "subject" doorzoeken als de index bestaat uit "subject" en "title". Het zal altijd beide velden zijn.

Voltekst bevat vaak bepaalde dingen waarop we niet willen zoeken, maar toch in de resultaten verschijnen omdat onze zoekopdracht nu éénmaal deze woorden bevat om deze grammaticaal correct te maken. Stel dat een gebruiker nu een "een huis" intypt als zoekopdracht. Het zou dan voor deze gebruiker vervelend kunnen zijn zouden ook alle resultaten met het woord "een" verschijnen. Deze informatie is immers irrelevant. In MongoDB kan men omwille van deze reden een taal specificeren bij het aanmaken van een tekstindex. Neem nu de volgende code.
\begin{lstlisting}
db.quotes.ensureIndex(
   { content : "text" },
   { default_language: "Dutch" }
)
\end{lstlisting}
Dit vertelt MongoDB dat de data van het veld "content" Nederlandse tekst bevat. MongoDB kan hier dan op inspelen door automatisch veelgebruikte woorden zoals "een" en "het" uit de zoekopdracht te filteren.

Wanneer de de index is aangemaakt en er enkele documenten aan toegevoegd zijn kan men de collectie doorzoeken via full text search. Zoals eerder uitgelegd is geweest doet men dit via de \$text operator

\subsubsection{Mongoose}
Mongo is op zichzelf slechts een simpele databank. MongoDB ondersteunt voornamelijk het opslaan en opvragen van JSON objecten. Achter MongoDB zit Javascript. De kunst bestaat eruit deze achterliggende javascript motor te gebruiken om ermee de data te manipuleren. Voor bijvoorbeeld het filteren en groeperen van data kan men de mapreducefunctionaliteit gebruiken.
\begin{lstlisting}
db.tracks.mapReduce(function() {
	var hourDate = this.eindtijd - this.begintijd;
	var onehour = 1000 * 60 * 60;
	var finalhour = Math.round(hourDate/onehour);
	emit(this.project, finalhour);
}, function(key, values) {
	return Array.sum(values);
}, {
	query: {gebruiker: ObjectId("54e468129300f83950bc2a63")},
	out: {inline: 1}
})
\end{lstlisting}
Dit bestaat uit enkele stappen. Eerst wordt de collectie doorzocht en gefilterd door een query. Elk document dat deze query oplevert wordt doorgegeven aan de mapfunctie die meegegeven werd met het mapreducecommando. Deze voert bij ieder document dat hij meekrijgt enkele regels code uit. De gebruiker is er vrij in om te bepalen welke code er precies moet worden uitgevoerd tijdens deze functie. Zolang dat de functie maar bestaat uit legitieme javascript code en hij puur functioneel is. Nadat deze functie is voeren we een "emit" uit waaraan we een key en een value geven. Als we nog nooit een document zijn tegengekomen met de key wordt er een nieuwe verzameling gemaakt. Als we wel al een ander document met de key zijn tegengekomen wordt deze aan de verzameling toegevoegd. Alle resulterende verzamelingen gaan vervolgens door de reducefunctie. Deze functie werd ook meegegeven aan het mapreduce commando en ook hier gelden dezelfde regels. Deze functie kan eender welke javascript code bevatten zolang het pure functionele code is. Deze functie zorgt ervoor dat de verzameling van values herleid wordt tot één value.

Wanneer het volledige commando is uitgevoerd krijgen we uiteindelijk een nieuw gegeneerd object teruggestuurd dat bestaat uit alle keys die we zijn tegengekomen plus daarbij de gereduceerde value. Dit ziet er ongeveer zo uit.
\begin{lstlisting}
{
	"results" : [
		{
			"_id" : ObjectId("54e49d7ad87060420fd417c5"),
			"value" : 5
		},
		{
			"_id" : ObjectId("54e4b13232c5b7ef11533c02"),
			"value" : 3
		}
	],
	"timeMillis" : 1,
	"counts" : {
		"input" : 4,
		"emit" : 4,
		"reduce" : 1,
		"output" : 2
	},
	"ok" : 1
}
\end{lstlisting}

Omdat het uitvoeren van zulke commando's echter moeilijk blijft, zorgt mongoose ervoor dat men bepaalde van mongo kan afdwingen zodat men een meer traditionelere ervaring heeft. Mongoose is een Javascript bibliotheek die ervoor zorgt dat men gebruik kan maken van zogenoemde schema's. Wanneer men een schema maakt legt men aan mongoose uit hoe de documenten er in een bepaalde collectie van je database er zouden moeten uitzien. Men kan bijvoorbeeld zeggen dat we een collectie met studenten hebben die bestaat uit documenten die allemaal een string hebben genaamd naam en een integer genaamd leeftijd. Mongoose zal dan zo goed en zo kwaad mogelijk proberen om dit model af te dwingen. Men kan nog steeds documenten in de databank hebben die niet aan deze waarden voldoen, maar men kan niet meer per ongeluk foute documenten maken zolang men de documenten aanmaakt via het mongoose framework. Voorbeeld van zulk een schema.
\begin{lstlisting}
var klantSchema = new Schema ({
	naam: String,
	telefoonnummer: String,
	email: String,
	gebruiker: {type: Schema.Types.ObjectId, ref: 'Gebruiker'}
}, {collection: "klanten"});
\end{lstlisting}

\subsection{Express}
Express is een bibliotheek die het maken van webapplicaties met nodejs vergemakkelijkt. Het vormt een extra laag bovenop nodejs. Het ondersteunt verschillende features. De feature waar wij het meest gebruik van gaan maken is de routing feature. Dit laat ons toe om routes te maken. Dit wil zeggen dat men een bepaalde url gaat koppelen aan een functie in JavaScript. Wanneer er dan naar deze url gesurft wordt, wordt deze functie uitgevoerd. Meestal worden er dan dingen uit de databank opgehaald naargelang de parameters die bij het request worden meegegeven. Daarna sturen we dat resultaat terug als een JSON Object.

\subsection{AngularJS}
%nog uit te leggen
%	scopes.

Voor dit project gaan we gebruik maken van AngularJS. Dit is een javascript framework bedoeld voor het vergemakkelijken van een Model View Controller webapplicatie. In tegenstelling tot vele andere model-view-controller frameworks voor webapplicaties, is AngularJS volledig geschreven in JavaScript. Dit heeft tot gevolg dat de applicatie volledig client-side kan werken. Dit heeft dan weer het voordeel dat de applicatie veel sneller zal draaien omdat er minder requests nodig zijn naar de server. Het Angular framework is volledig modulair opgebouwd. Een Angular applicatie bestaat typisch uit enkele modules. Deze modules kunnen verspreid zijn over meerdere bestanden. Wanneer men een applicatie opstart moet men meegeven welke moduels de applicatie precies gebruikt. Dit gebeurd als volgt.

\begin{lstlisting}[language=javascript]
var var seanclogApp = angular.module('seanclogApp',
		['seanClogServices', 'seanClogControllers', 'ngRoute', 'ui.grid',
		 'pascalprecht.translate']);
\end{lstlisting}

Zoals u zelf waarschijnlijk zult merken is de applicatie zelf ook een module. Dit module systeem heeft zijn voordelen. Stel dat men de controllers van een de ene applicatie wilt gebruiken in een andere. Dan hoeft men enkel het bestand dat deze module bevat te kopiëren naar de broncode van de andere applicatie. Als dat gedaan is en het bronbestand geladen wordt door één van de webpagina's van uw applicatie moet men deze module registreren door deze aan de applicatie toe te voegen. Dit gaat als volgt.

\begin{lstlisting}[language=javascript]
var seanclogApp = angular.module('seanclogApp',
		['seanClogServices', 'seanClogControllers', 'ngRoute', 'ui.grid',
		 'pascalprecht.translate', 'mijnNieuweModule']);
\end{lstlisting}

In dit voorbeeld staat "mijnNiueweModule" voor de module die u zopas heeft toegevoegd.

\subsubsection{Views}
Omdat deze applicatie het model view controller design pattern gaat volgen gaan we ook gebruik maken van views. Deze views worden beheerd door AngularJS. Wanneer de gebruiker naar de root van onze applicatie navigeert (dit wil zeggen http://mydomain.com/) levert de applicatie zoals gewoonlijk een html pagina geleverd genaamd "index.html". Dit is echter meteen de enige echte webpagina die de gebruiker zal ontvangen. De rest zit vervat in code die samen verzonden wordt met de webpagina. Deze code beslist welke views er op welk moment getoond moeten worden.

Deze pagina ziet er als volgt uit
%FIXME: Ik gebruik hier geen tags, maar attributen
\begin{lstlisting}[language=html]
<html>
	<head>
		<!-- hier zetten we alle scripts die nodig zijn voor het draaien van de applicatie -->
	</head>
	<body>
		<div ng-view> <!-- hier komen de views --></div>
	</body>
</html>
\end{lstlisting}
Deze views zijn niets meer dan gewone webpagina's die tussen de broncode geworpen worden, op de plek waar de ngview tag staat. Deze code wordt dan in zijn geheel verwerkt door de webbrowser. De views kunnen bestaan uit één of meerdere subviews. Deze subviews kunnen worden toegevoegd door het gebruik van de ng-include tag. Stel dat men de volgende view heeft:
\begin{lstlisting}[language=html]
<div id="myview">
<p>Dit is een test</p>
</div>
\end{lstlisting}
Dan zou men hier code uit een ander bestand er aan kunnen toevoegen.
\begin{lstlisting}[language=html]
<div id="myview">
<p>Dit is een test</p>
<div ng-include="'/partials/view2'"
</div>
\end{lstlisting}

\subsubsection{Controllers}
%hier schrijven over het opsplitsen van de controllers
%Iedere resource heeft zijn eigen controller en door middel van het angular modulesysteem zetten we iedere
%controller in een eigen bestand. Op die manier blijft onze code ordelijk.

Wat betreft de controllers heb ik besloten om volledig gebruik te maken van Angulars kracht. Het modulaire systeem van AngularJS staat de programmeur toe om het programma in meerdere bestanden op te splitsen zolang men deze javascripts maar laad in de applicatie. Dit rekeninghoudend met de afhankelijkheid tussen de modules onderling.

Ik heb ervoor gekozen om voor iedere resource een controller te voorzien. Dit is in de meeste gevallen de aangewezen methode bij het maken van applicaties in het Model View controller patroon %Leg uit wat model view controller is.
Dit wil zeggen dat mochten we een resource genaamd klanten hebben, ik de applicatie ga voorzien van een controller genaamd klanten waarin alle procedures voor het afhandelen van informatie omtrent klanten, in zit vervat.  Dit gaat onder meer over bewerken, verwijderen, maken, plus nog enkele mogelijke hulpfuncties.

\subsubsection{Services}
Het ophalen van data van de database door de client gebeurt door middel van services. Services zijn een concept binnen AngularJS en kunnen gezien worden als singletons. Een service wordt gemaakt door de factory methode op te roepen van de het applicatieobject. Dit krijg twee parameters mee. De eerste parameter is een naam. Deze naam zal later gebruikt worden om naar onze service te kunnen refereren. De tweede parameter is een functie die een object hoort terug te geven. Dit object kan allerlei dingen bevatten. Variabelen, functies, het is kortom een volwaardig object. De bedoeling is dat dit object vanaf elke plek binnen onze applicatie beschikbaar zal zijn. We kunnen deze services in andere modules gebruiken. Bij het maken van een module moet er namelijk een array doorgegeven worden. Deze array is een lijst met strings. Deze strings zijn namen van services. Zo weet angular welke services in een module worden gebruikt. De genoemde services moeten daarna enkel als parameter genoemd worden in de functie gekoppeld aan de module. Daarbij zijn ze ook nog eens lui geïnitialiseerd. Dit wil zeggen dat Angular deze objecten enkel aanmaakt wanneer ze echt worden gebruikt. Men kan bijvoorbeeld een module laden waarin een service vervat zit, maar waarvan geen gebruik gemaakt wordt. Mocht deze service toch geïnitialiseerd worden, neemt deze onnodig plek in het geheugen en kan deze de applicatie nodeloos vertragen. Door deze techniek kan Angular sneller werken en hebben Angular applicaties een lagere memory-footprint.

De volgende voorbeeldcode stelt een service voor die toegang geeft tot de "Klant" route. De gekoppelde functie maakt een zogenaamd resource object aan. Dit is een object dat bij creatie een URI ontvangt (meestal is dit een route van een RESTAPI) en daarna enkele methodes maakt die een request versturen naar deze URI. Deze methodes zijn analoog met de REST methodes.
\begin{lstlisting}

seanclogclient.factory('Klanten', [ '$resource', function($resource) {
	var fact = $resource('/api/clients/:id', {}, {
		'query' : {
			method : 'GET',
			isArray : true
		},
		'post' : {
			method : 'POST',
			params : {}
		},
		'remove': {
			method: 'DELETE',
			params: {}
		},
		'update': {
			method: 'PUT',
			params: {}
		}
	});
	return fact;
}]);

\end{lstlisting}

Normaal gezien worden deze methodes impliciet aangemaakt. Men kan deze methodes echter ook expliciet aanmaken, zoals in het bovenstaande voorbeeld. Dit laat de programmeur toe om enkele standaard opties aan te passen.

\subsubsection{Filters}
%Hier schrijven over de datumfilter die ik heb gemaakt.

\subsubsection{Directives}
%Het is niet de naam maar de ng-model
Voor het maken van deze applicatie heb ik het voorzien van één custom directive genaamd ng-match. Deze zorgt ervoor dat de inhoud van het éne invoerveld overeenstemt met het andere. Stel dat men een formulier heeft en dat formulier heeft een invoerveld genaamd wachtwoord. Dan kan men de gebruiker dwingen dezelfde tekst in een tweede invoerveld te schrijven door dat invoerveld te voorzien van het ng-match attribuut, met als waarde dezelfde als de naam van het eerste invoerveld. Wanneer de waarde van het tweede invoerveld niet overeenstemt met de waarde van het eerste is de waarde niet geldig en wordt deze niet opgestuurd naar de server. \cite{angular:directives}

\begin{lstlisting}[language=javascript]
seanclogSecurity.directive('ngMatch', ['$parse', function($parse) {
	//ngmatch directive
	
	function link(scope, elem, attrs, ctrl) {
		if(!ctrl) return;
		if(!attrs['ngMatch']) return;
		
		var firstPassword = $parse(attrs['ngMatch']);
		
		var validator = function(value) {
			var temp = firstPassword(scope);
			var v = (value === temp);
			ctrl.$setValidity('match', v);
			return value;
		};
		
		ctrl.$parsers.unshift(validator);
		ctrl.$formatters.push(validator);
		attrs.$observe('ngMatch', function() {
			validator(ctrl.$viewValue);
		});
	}
	
	return {
		link: link,
		restrict: 'A',
		require: '?ngModel'
	};
}]);
\end{lstlisting}
\paragraph{matchen van directives}
Directives moeten door Angular op een bepaalde manier genormaliseerd worden zodat we naar deze directives kunnen refereren in de broncode. Normaal gesproken gebruiken we hiervoor camelcase. Omdat HTML echter niet hoofdletter gevoelig is worden aangepaste directives meestal aangeduid via een andere notatie. Stel dat men een directive maakt genaamd ngHello, dan wordt binnen Javascript gewoon de naam ngHello gebruikt en binnen HTML de naam "ng-hello".

Eigen directives kunnen in de volgende vormen gematched worden \\
\begin{large}
\textbf{Via de naam van de tag}
\end{large}
\begin{lstlisting}
<ng-hello>some data</ng-hello>
\end{lstlisting}
\begin{large}
\textbf{Via de naam van de klasse}
\end{large}
\begin{lstlisting}
<span class="ng-hello">some data</span>
\end{lstlisting}
\begin{large}
\textbf{via de commentaar}
\end{large}
\begin{lstlisting}
<!-- directive ng-hello some data -->
\end{lstlisting}
\begin{large}
\textbf{Via de naam van het attribuut}
\end{large}
\begin{lstlisting}
<span ng-hello="some data></span>
\end{lstlisting}

Angular zelf raadt aan om enkel gebruik te maken van de tag- en de attribuut-methode.

\subsubsection{Data validatie}
%Nagaan of de required direcitve wel degelijk iets van angular is
Men kan er niet altijd op vertrouwen dat de gebruiker de data op de juiste manier invoert. Om er zeker van te zijn dat er valide gegegevens ingegeven worden in de formulieren gaan we de gebruiker hier dus in bijstaan en validatie toepasssen. AngularJS heeft hiervoor enkele systemen ingebouwd. Het is mogelijk om binnen een formulier, velden aan te duiden die noodzakelijk zijn. Stel dat men bijvoorbeeld een klant wilt aanmaken. Dan heeft die klant een naam nodig. We kunnen die als volgt adwingen
\begin{lstlisting}[language=html]
<input type="text" ng-model="klant.naam" class="form-control" required />
\end{lstlisting}

We kunnen ook een bepaald type invoer afdwingen. We kunnen ervoor zorgen dat de gebruiker enkel nummers kan invoeren. Dit doen we door het type-attribuut van text naan number te veranderen.

Wanneer een invoerveld binnen een formulier niet geldig blijkt te zijn, zal Angular dit invoerveld toewijzen aan de klasse "ng-invalid". Als programmeur kan ik dan op deze klasse enkele stijlen toepassen die er bijvoorbeeld voor zorgen dat niet geldige invoervelden rood kleuren. Hetzelfde gebeurd met geldige invoervelden door middel van de "ng-valid" klasse. Verder krijgt een formulier in AngularJS een aantal extra objecten mee. Eén van die objecten is een object genaamd \$error. Dit object bevat informatie over welke invoervelden er op dat moment geldig zijn en welke niet. Stel dat men een invoerveld heeft met de naam "email". Wanneer dit invoerveld de text "blahblah" bevat zal het object "myform.email.\$error.eamil" de waarde true bevatten.

\subsubsection{Scopes}
\paragraph{Wat zijn scopes?}
De scope is het object dat refereert naar het applicatiemodel. Het is de context waarin alle expressies binnen een controller worden uitgevoerd. Scopes worden geschikt in een hiërarchische structuur. Scopes kunnen expressies opvolgen en events invullen.\cite{angular:scopes}

\paragraph{Kenmerken van scopes}
Scopes voorzien in een aantal diensten. Een van die diensten heet "\$watch". Deze kan benut worden om voor het opvolgen van bepaalde variabelen binnen de scope. In de onderstaande code wordt te variabele met de naam "name" opgevolgd. Wanneer deze wordt veranderd wordt er een interne counter verhoogt. Welke nu precies de waarde was van "name" en welke die nu is wordt genegeerd.
\begin{lstlisting}
scope.$watch('name', function(newValue, oldValue) {
  scope.counter = scope.counter + 1;
});
\end{lstlisting}

Daarnaast is er nog een dienst genaamd "\$apply" Deze kan worden gebruikt om expressies te evalueren die geen deel uitmaken van het Angular framework en deze dan te gebruiken in de view.

Scopes kunnen in elkaar genest worden. Zo kan men de toegang door componenten tot bepaalde variabelen verhinderen terwijl men toch een gedeeld model heeft. Scopes kunnen op die manier oftewel child scopes zijn. Wat betekent dat ze de eigenschappen van de parent overerven, oftewel een geïsoleerde scope, waar dit laatste dus niet gebeurd.

\paragraph{Scope als datamodel}
Scopes vormen de verbinding tussen de controller en de view. Bij het linken van de view aan de controller maken de Angular directives in de views \$watch expressies. Op die manier worden de directives gewaarschuwd wanneer één van de variabelen binnen de scope verandert. Op die manier kan de directive ervoor zorgen dat de DOM altijd geüpdatet is.

Zowel de controllers als de directives gebruiken de scope om te kijken of er een bepaalde variabele geüpdatet is. Ze hebben echter geen kennis van elkaar. Enkel de scope. Dit is belangrijk in verband met testing gezien dit ervoor zorgt dat men de DOM kan veranderen en kijken of de controller erop reageert.

\begin{lstlisting}
angular.module('scopeExample', [])
.controller('MyController', ['$scope', function($scope) {
  $scope.username = 'World';

  $scope.sayHello = function() {
    $scope.greeting = 'Hello ' + $scope.username + '!';
  };
}]);
\end{lstlisting}

In het bovenstaande voorbeeld worden er drie variabelen in de scope gestoken. Username, die een string bevat en een functie genaamd sayhello die de inhoud van de variabele greeting veranderd naar hello plus datgene wat er in de username variabele zit. Neem de volgende code

\begin{lstlisting}[language=html]
<html ng-app="scopeExample">
	<div ng-controller="MyController">
		<input ng-model="username"/>
		<button ng-click="sayHello">Click me</button>
		<span>{{greeting}}</span>
	</div>
</html>
\end{lstlisting}
De waarde van de ng-app attribuut bepaald welke Angularmodule de hoofdmodule is. Het attribuut ng-controller maakt een nieuwe scope en bepaald de naam van de controller die gebruikt zal worden om deze scope aan te spreken. De input in deze code heeft een ng-model attribuut. Deze bepaald aan welke variabele deze input gebonden wordt binnen de scope. De button heeft een ng-click attribuut. Deze bevat een angular expressie die geëvalueerd zal worden wanneer er op deze button geklikt wordt. In ons geval bestaat deze expressie uit een functie die uitgevoerd zal worden. De span helemaal onderaan bevat als inhoud een Angular expressie. Deze onderscheiden zich door doordat ze omringd worden door twee paar accolades. De gebruiker voert een een naam in in het invoerveld waardoor de variabele username in de scope zal veranderen. Wanneer er op de button geklikt wordt wordt de variabele greeting veranderd naar de waarde in username plus hello. Doordat er een expressie tussen de span staat kreeg deze ook een \$watch. Hierdoor wordt de verandering opgevangen en krijgt de span automatisch de nieuwe waarde als inhoud.

\section{Interne structuur} %hier heb ik wikipedia als bron gebruikt
De meeste applicaties zijn bedoeld voor het persisteren en het beheren van bepaalde gegevens. In sommige gevallen zijn dat gegevens van studenten. In ons geval zijn dat gegevens van klanten, projecten en tracks. Een computer kan hoofdzakelijk alleen wiskunde. Men zegt vaak dat een computer heel slim is, maar met alleen wiskunde kom je er in het leven. Wat we wel kunnen doen is de werkelijkheid proberen herleiden tot wiskunde. We kunnen de het gegeven dat wij willen bereiken op een zodanige manier noteren dat dit voor een computer begrijpbaar wordt. Hiervoor zijn programmeertalen erg handig. Ze laten ons toe om onszelf uit te drukken tegenover een computer. Als we alle gegevens op die manier zouden uitdrukken zouden we het volgende schema moeten bekomen.

\begin{center}
\begin{minipage}{\linewidth}
\centering
\includegraphics[scale=0.5]{model}
\end{minipage}
\end{center}

Het model van de applicatie is redelijk minimalistisch. Helemaal bovenaan staat de Gebruiker. Daarnaast heeft men alle soorten data waarmee die met de gebruiker geassocieerd kunnen zijn. Deze zijn.
\begin{description}
\item[Klanten] Klanten waarvoor men projecten kan maken.
\item[Projecten] Projecten die men voor een klant maakt. Deze projecten zijn verbonden aan tracks
\item[Tracks] Een bepaalde tijdspanne die men aan een project heeft gespendeerd.
\item[Token] Een validatietoken voor een gebruiker.
\end{description}

\subsection{RestAPI}
%Hier bespreken wij de RESTAPI
%Wij gaan voor deze applicatie gebruik maken van een RESTFUL api. Dit zorgt
%ervoor dat we makkelijk meerdere clents kunnen maken die ook op op desktops
%werken, telefoons, misschien zelfs een tv. De mogelijkheden zijn nagenoeg
%eindeloos.
%
%RestApi's worden doorgaans gebruikt voor het ophalen en het wegschrijven van
%data. Deze data kunnen uiteenlopende dingen zijn. Afbeeldingen, blogartikels,
%zelfs volledige objecten. Deze RestApi is meestal toegankelijk via het HTTP
%protocol. Dit zorgt ervoor dat het makkelijker is om clients te maken die deze
%API kunnen gebruiken omdat HTTP een alomvertegenwoordigd protocol heeft. Het is
%een protocol dat standaard in praktisch iedere networking api geïmplementeerd is
%en dat als dus danig door vele computers begrepen wordt.
%
%Elk type data (of resource) wordt voorgesteld door een uniform resource
%identifier (ofwel URI)
%
%Een RESTApi bestaat uit de volgende componenten.
%\begin{description}
%  \item [Get] Een get request
%  \item [Delete] Verwijder data
%  \item [Put] Verander data
%  \item [Post] Bewaar data
%\end{description}

Voor de ontwikkeling van de service werd er gekozen voor een RESTAPI. Een belangrijk gegeven dat men moet begrijpen bij het maken van een RESTAPI, is dat REST slechts een aantal regels zijn. Deze regels worden toegepast op het ontwerp van alle componenten van de applicatie om zodoende een schaalbare internetdienst te verkrijgen. Zo een dienst communiceert over het internet via het HTTP protocol door middel van de standaard HTTP methodes GET, POST, PUT, DELETE. Dit zijn de gewone standaard methodes die webbrowsers gebruiken voor het verkrijgen en verzenden van informatie via het internet. \cite{wiki:restapi}

Indien men de regels van een RESTAPI op een goede manier toepast, kan men een website met de volgende eigenschappen bekomen.

\begin{description}
\item[Schaalbaar] Een oneindig aantal componenten kan worden ondersteunt die met elkaar kunnen communiceren. Dit aantal componenten is ook uitbreidbaar tot in het oneindige.
\item[Simpelheid] De REST-architectuur zit heel simpel in elkaar, slechts gebruik makend van bestaande protocollen.
\item[Beheerbaarheid] Een RESTAPI is over het algemeen gemakkelijk te beheren. Er kan op ieder moment in de ontwikkeling een component worden toegevoegd, verwijderd of geüpdatet.
\item[Zichtbaarheid] De communicatie tussen client en server is zichtbaar voor programma's die het eventueel willen opvolgen. Tenzij er gebruik gemaakt wordt van https.
\item[Portability] Een service is gemakkelijk overzetbaar van de ene server op de andere server
\item[Betrouwbaarheid] Men kan de webserver die de API aanbiedt gemakkelijk zodanig afstellen dat er na 5 aanvragen gestopt moet worden met proberen. 
\end{description}

Een belangrijk basisprinciepe van REST is dat het resourcegebasseerd is. Iedere entiteit wordt door exact één enkele resource identifier voorgesteld. Op deze identifier worden dan de betrokken methodes PUT, DELETE, POST en GET uitgevoerd. Wanneer er een request wordt verstuurd naar de server wordt er een "representatie" van deze resource teruggestuurd in plaats van de resource zelf. De server gaat niet de databank verzenden, maar een tekst in de vorm van JSON, XML en anderen. Dit gefilterd door middel van de parameters die meegegeven werden tijdens de aanvraag.

De resources op de server worden ook bewerkt door middel van deze presentaties. Dit wil zeggen dat, wanneer een client een resource wilt aanpassen, deze de resource die hij wilt aanpassen, moet omzetten in een JSON (indien de server gebruik maakt van JSON). Deze informatie kan eventueel nog metadata bevatten. Bijvoorbeeld het identificatienummer van de resource die moet worden aangepast. Deze resource moet worden verstuurd naar de URI van de resource die men wilt aanpassen met de UPDATE methode. De server zal dan de resource aanpassen, op voorwaarde dat deze de rechten hiertoe bezit.

Ieder bericht dat verzonden wordt naar de server bevat genoeg informatie voor het verwerken van dat bericht. Dit wil zeggen dat het bericht voldoende metadata bevat voor de volledige uitvoer. Stel dat men een informatie van een klant zou willen opslagen en die informatie is gekoppeld aan een gebruiker van de applicatie, dan zou het bericht niet alleen de informatie van die klant moeten bevatten, maar ook van de gebruiker en dit op voldoende wijze zodat de gebruiker eraan gekoppeld kan worden.

De status van zowel de server als de client moet verstuurd worden via "bodies" van doorgestuurde data (dit wil zeggen: doorgestuurde json objecten), query strings, request headers en ga zo maar door. Kort gezegd wordt de gehele status van de applicatie doorgegeven via hypermedia.

\subsubsection{URI}
Zoals eerder gezegd wordt bij een RESTAPI de resources voorgesteld door URI's. Deze applicatie volgt hierin een gemakkelijk te volgen structuur. Iedere URI correspondeert met een collectie binnen MongoDB. Men start de URI met "/api/" om aan te geven dat men een oproep op de API wilt doen. Daarna geeft men de collectie op waarop men een bewerking wilt uitvoeren. De collectie projecten wordt bijvoorbeeld aangeduid door projects. Dit geeft "/api/projects". Daarna kan men, afhankelijk van de operatie die men wilt uitvoeren. Stel dat men bijvoorbeeld het project met de ID 12345 wilt bewerken geeft dit "/api/projects/12345". De applicatie ondersteunt enkel de methodes POST, UPDATE, en DELETE op deze manier. Normaal gesproken zou, in een complete RESTAPI dit ook met GET moeten werken. In dat geval zou enkel de resource met het opgegeven ID moet worden teruggestuurd, maar omdat dit nooit in één van de front ends van de applicatie nodig is geweest. Is dit bijgevolg dus nog niet geïmplementeerd. Wanneer dit gedaan is moet er nog een access token voorkomen in de query string. Dit is een token die gekoppeld is aan een gebruiker van de applicatie. Op deze manier wordt er nagekeken of de request legitiem is en of de gebruiker het recht heeft om de bewerking uit te voeren. Uiteindelijk zal men de volgende URI bekomen "/api/projects?access\_token=abcd1234".

\paragraph{/api/users}
Hiermee worden de gegevens bewerkt in de gebruikers collectie. De gebruikers collectie bevat documenten met daarin de gegeven van, logisch, de gebruikers van de applicatie. Dit is onder andere het wachtwoord, de naam, het email adres en dergelijke. Het wachtwoord wordt niet opgeslagen als leesbare tekst. In plaats daarvan slaan we de tekst op met een MD5 codering. MD5 is een algoritme dat vrij tekst kan omzetten naar een tekenreeks die in de verste verte niet op de originele tekst lijkt. Maar telkens wanneer men eenzelfde tekst door het algoritme voert bekomt men dezelfde tekenreeks. Wanneer een gebruiker aanlogt wordt deze tekenreeks vergeleken met datgene wat we hebben opgeslagen in de databank. Op die manier moeten we nooit het echt wachtwoord opslaan. Deze route ondersteunt de volgende methodes.

\begin{description}
\item[GET] Stuurt de gebruikersgegevens terug van de gebruiker die gekoppeld is aan de token meegegeven in de query string
\item[POST] Maakt een nieuwe gebruiker aan.
\item[PUT] Werkt de gebruiker bij die gekoppeld is aan de meegegeven access token. De nieuwe gebruikersgegevens worden meegegeven als JSON object via de requestbody.
\item[DELETE] Verwijdert de gebruiker die gekoppeld is aan de meegegeven access token.
\end{description}

\paragraph{/api/projects/:id}
Hiermee worden de gegevens bewerkt in de "Projecten" collectie. Een project is een werk waar een gebruiker voor een lange tijd aan bezig is en wordt gekoppeld aan een klant. Deze route ondersteunt de volgende methodes.

\begin{description}
\item[GET] Stuurt alle projecten terug van de gebruiker die gekoppeld is aan de meegegeven access token
\item[DELETE] Verwijdert het project gekoppeld aan het meegegeven ID. Ook alle tracks die gekoppeld zijn aan dit project worden automatisch verwijderd.
\item[PUT] Werkt het project bij van de gebruiker gekoppeld aan aan de meegegeven access token. De gegevens die bijgewerkt moeten worden, worden bepaald door het JSON object in de de request body. Het project dat zal worden bijgewerkt is dat project met de ID gelijk aan het ID veld in de request body.
\item[POST] Maakt een project aan voor de gebruiker gekoppeld aan de meegegeven access token. Het project dat aangemaakt moet worden wordt meegegeven als JSON via de request body
\end{description}

\paragraph{/api/clients/:id}
Hiermee worden gegevens bewerkt in de "klanten collectie. Een klant is een bedrijf of een persoon waarvoor een gebruiker een project kan hebben.
\begin{description}
\item[GET] Stuurt alle klanten terug van de gebruiker die gekoppeld is aan de meegegeven access token.
\item[DELETE] Verwijdert de klant met de meegegeven ID op voorwaarde dat deze klant aangemaakt is geweest door de gebruiker die gekoppeld is aan de meegegeven access token. Hiermee worden ook automatisch alle projecten verwijderd die gekoppeld zijn aan de klant die verwijderd wordt.
\item[PUT] Werkt de klant bij met de meegegeven ID. De nieuwe gegevens voor de klant worden meegegeven via de request body in JSON formaat. Deze operatie wordt enkel uitgevoerd als de klant aangemaakt is geweest door de gebruiker die gekoppeld is aan de meegegeven access token.
\item[POST] Maakt een nieuwe klant aan met de gegeven die meegegeven worden in JSON formaat via de request body.
\end{description}

\paragraph{/api/tracks/:id}
Hiermee worden de gegevens bewerkt van de "Tracks" collectie. Een track is één bepaalde tijdspanne die een gebruiker aan één bepaald project spendeert.
\begin{description}
\item[GET] Dit stuurt alle tracks terug van de gebruiker die gekoppeld is aan de meegegeven access token.
\item[POST] Hiermee wordt er een nieuwe track gemaakt. De track die aangemaakt moet worden, wordt meegegeven via de request body in de vorm van een JSON object. De track wordt gekoppeld aan de gebruiker met de meegegeven access token
\item[PUT] Hiermee wordt de track bijgewerkt met de meegegeven ID. De nieuwe gegevens worden doorgegeven als JSON object via de request body. Deze operatie wordt niet uitgevoerd als de gebruiker die gekoppeld is aan de meegegeven access token, geen eigenaar is van de track.
\item[DELETE] Hiermee wordt de track met de meegegeven ID verwijderd. Deze operatie wordt niet uitgevoerd als de gebruiker, gekoppeld aan de meegegeven access token geen eigenaar is van de track.
\end{description}

\paragraph{/api/users/changepassword}
Deze route wordt enkel gebruikt voor het wijzigen van wachtwoorden en reageert slechts op één methode
\begin{description}
\item[PUT] Hiermee wordt het wachtwoord bewerkt van de gebruiker gekoppeld aan de meegegeven access token. Hierbij wordt er een JSON object meegegeven via de request body. Dit JSON object bevat slecht één veld genaamd wachtwoord, met daarin het nieuwe wachtwoord.
\end{description}

\subsection{Beveiliging}
\subsubsection{Tokens}
Het hebben van een goede applicatie betekent niet alleen dat de applicatie er goed uit moet zien. Klanten vertrouwen ons hun gegevens toe. Daarom moeten we erop toezien dat de applicatie goed beveiligd is. Dit hoop ik te bereiken door het gebruik van token based authenticatie. Wanneer een gebruiker zich aanmeldt zouden we alle gebruikers kunnen opsturen. Inclusief het wachtwoord. Wanneer de gebruiker dan data wilt opvragen zou deze terug zijn wachtwoord kunnen opsturen om zijn aanvraag te doen gelden. Dit gaan we echter niet doen. In plaats daarvan gaan we iedere gebruiker een token geven. De bedoeling is dat deze token opgestuurd zal worden in plaats van het wachtwoord. De tokens worden opgeslagen in een aparte collectie tezamen met de een veld waarin de datum staat wanneer de token is gemaakt. Telkens wanneer er een aanvraag afgehandeld wordt, wordt de token meegegeven via de query parameters. Dit wil zeggen de GET paramters. Hierna wordt er naar deze token gezocht. Als deze token bestaat, wordt er gekeken naar de leeftijd van de token. Mocht deze ouder zijn dan zeven dagen wordt er een foutboodschap teruggestuurd. Is dit niet het geval, dan is de aanvraag geautoriseerd en ontvangt de gebruiker zijn gevraagde gegevens. Mocht de token helemaal niet bestaan wordt er tevens een foutboodschap teruggestuurd. Telkens wanneer de token niet bestaat of deze vervallen is dient te gebruiker een nieuwe te genereren door zich opnieuw aan te melden.

\subsubsection{Emailverificatie}
Het is natuurlijk niet handig mochten gebruikers zomaar een gebruikersaccount kunnen aanmaken met een ongeldig emailadres. Daarom wordt er, wanneer een nieuwe gebruiker wordt aangemaakt, een verficatieemail naar de gebruiker verstuurd via het emailadres dat de gebruiker heeft opgegeven bij aanmelding. Dit wordt verwezenlijkt door nieuwe gebruikers te voorzien van een extra "validated" veld. Wanneer een gebruiker pas is aangemaakt staat dit veld op vals.? Daarna wordt er een email opgestuurd. Deze email bevat een link en in deze link zit het identificatienummer van de gebruiker vervat verwijst naar een functie binnen de webdienst. De bedoeling is dat de gebruiker hierop klikt en wanneer dat gebeurd wordt het identificatienummer nagegaan en wordt het validated veld op true gezet. Zolang het validated veld op false staat, kan de gebruiker niet aanmelden.

Om de applicatie beter te kunnen testen, kan deze functionaliteit uitgeschakeld worden. In het configuratiebestand van de applicatie zit er waarde genaamd "devmode". Indien deze waarde true is, wordt de emailverificatie uitgeschakeld. Zie voorbeeld
\begin{lstlisting}
{
	"host": "localhost",
	"db": "test",
	"user": "",
	"password": "",
	"devmode": "true",
	"baseurl": "http://localhost:5000"
}
\end{lstlisting}
In dit voorbeeld is de emailverificatie uitgeschakeld.

\subsection{Tests}
De reliability van de applicatie cruciaal. Het gaat hier immers om een webapplictatie. De applicatie moet erop gebouwd zijn dat deze redelijk veel requests kan ontvangen en vooral, mochten deze requests fout opgesteld zijn, dat de applicatie deze opvangt en afhandelt zonder zelf te crashen. We zouden dit kunnen testen door zelf via de front-end foute data in te voeren, maar dit is onpraktisch. De applicatie is er immers op gebouwd om nooit foute data door te geven. Iedere data die ingevoerd wordt, wordt gevalideerd. Dit wilt echter niet zeggen dat de back-end de data ook goed valideert. In de wereld van JavaScript bestaan er hiervoor vele tools. Voor deze applicatie werd er gekozen voor Mocha. Mocha laat toe tests te groeperen en te rangschikken. Men kan er ook mee beslissen wat er precies na een test moet gebeuren en ervoor. Ook is het mogelijk om via Mocha asynchrone functies te testen.

\begin{lstlisting}
describe('projectsapi', function() {
	var logintoken;
	var toBeDeleted = 0;
	var tmpclient;
	before(function(done) {
		request.post('http://localhost:5000/api/login')
		.send({username: 'pieter', password: '12345'})
		.end(function(res) {
			logintoken = res.body.token;
			
			tmpclient = new api.model.Klant({
				naam: "mocha test klant",
				telefoonnummer: '7522552',
				email: 'ldkfjsqlkf@oqdfjlqdkfj.com'
			});
			
			done();
		});
	});
	afterEach(function(done) {
		if(toBeDeleted != 0) {
			request.del('http://localhost:5000/api/projects/' + toBeDeleted)
			.query({access_token: logintoken})
			.end(function(res) {
				toBeDeleted = 0;
				done()
			});
		} else {
			done();
		}
	});
	it('should do a full text search', function(done) {
		var tmpproj = new api.model.Project({
			titel: 'mocha test project',
			prijs: 12.50,
			klant: tmpclient
		});
		
		request.post('http://localhost:5000/api/projects')
		.send(tmpproj)
		.query({access_token: logintoken})
		.end(function(res) {
			toBeDeleted = res.body.savedId;
			request.get('http://localhost:5000/api/projects')
			.query({access_token: logintoken, search: 'mocha project'})
			.end(function(res) {
				var found = res.body[0];
				expect(found.titel).to.be("mocha test project");
				done();
			});
		});
	});	
});
\end{lstlisting}
De bovenstaande code toont een test voor het uitproberen van Mongo full text search. De tests spreken hiervoor uiteraard de RESTAPI van de applicatie aan vermits deze getest moet worden. Het uitvoeren van de requests gebeurt door superfetch. Deze api voorziet de functies get, post, put en delete. Er wordt de uri van de te testen resource opgegeven en alle informatie, zoals logintoken en testdata, wordt doorgegeven via chained calls. Deze chained call wordt afgesloten door de functie "end" die een andere functie als parameter meekrijgt. Ieder request van superfetch loopt immers asynchroon. Omdat ieder request asynchroon loopt krijgt de test via mocha een extra parameter mee genaamd done. Het is de bedoeling dat deze functie aangeroepen wordt wanneer alles getest is zodat mocha weet dat de test afgelopen is.

Om uiteindelijk de waarden te testen die de requests ons terugsturen maken we gebruik van nog een extra bibliotheek genaamd expect.js. Deze biedt functies die als parameter de teruggestuurde waarden van de request mee krijgen plus nog een extra parameter om de waarden aan te geven die we verwachten, mocht de test goed verlopen. Mochten de waarden niet kloppen, dan gooit expect.js een error object dat door mocha opgevangen wordt. Mocha interpreteert dit als een slecht afgelopen test.

Buiten de test moet men ook rekening houden met wat er voor en wat er na een test moet gebeuren. Mocha biedt namelijk ondersteuning om dit te kunnen beïnvloeden. Dit gebeurt via de functies "before", "beforeEach", "after" en "afterEach". Met "before" en "after" beslist men wat er voor en na het starten van de gehele testsuite moet gebeuren. Met "afterEach" en "beforeEach" beslist men wat er na iedere test moet gebeuren.

In deze testsuite wordt er op die manier voor het begin van de testsuite ingelogd en wordt, na iedere test, de testdata verwijderd. Ook deze functies kunnen voorzien worden van een "done" parameter om aan te geven dat de functies "before" en consorten zijn afgelopen.

\section{vormgeving}

%Ik moet hier meer informatie over opzoeken
\subsection{Bootstrap}
Zelf ben ik niet zo een goede designer. Daarom heb ik besloten om deze klus uit te besteden aan een voorgekauwde collectie van CSS templates beter bekend als Bootstrap. Boostrap word meestal gebruikt om er zeker van te zijn dat de uiteindelijke website cross-browser zal werken. Op dit moment werkt Bootstrap op zowat alle moderne browsers. Deze templates zijn ook zodanig gemaakt dat de layout zich gemakkelijk aanpast aan verschillende grootten van schermen. Hete ondersteunt verschillende complexe layouts. Men kan er bijvoorbeeld voor zorgen dat de widgets automatisch in rijen staan en de breedte van het browserscherm gelijkmatig verdeeld wordt tussen de widgets.

\subsubsection{Responsief design}
Tegenwoordig gebruikt men meer dan alleen een computer. Andere toestellen zoals een Smartphone en een Tablet komen alsmaar vaker voor in het dagelijkse leven. Deze toestellen worden voor meer dan alleen bellen gebruikt. Een smartphone heeft tegenwoordig allerlei doeleinden. Om ervoor te zorgen dat deze applicatie ook tot één van die doeleinden zal behoren, werd er op bepaalde hoogte aandacht gespendeerd aan een responsief design.

Wanneer het scherm te klein wordt om het hele menu op één regel te bevatten, wordt dit menu verdeeld over meerdere regels. Bovendien wordt ook het zoekveld en de zoekknop weggehaald. Wanneer de van de tabel niet meer op het scherm passen, worden deze kolommen onder elkaar geplaatst. Dit laatste wordt mogelijk gemaakt door de volgende code.

\begin{lstlisting}[language=css]
@media (max-width: 767px) {
	.supertable th {
		display: none;
	}
	.supertable td {
		display: block;
	}
	.hidetobig {
		display: none;
	}
	
}

\end{lstlisting}

\subsection{Vertalingen}
We kunnen er niet van uit gaan dat iedereen dezelfde taal spreekt. Zeker niet in een land als België. Daarom gedragen we ons als een echte wereldburger en ondersteunen we meerdere talen. De vertalingen worden verzorgt door een extra angular module genaamd angular-gettext. Gettext is eigenlijk een technologie die deel uitmaakt van het GNU systeem. Omdat dit een opensource systeem is komt het vaak voor dat de mensen die eraan meewerken niet zozeer een enorme kennis hebben over ICT. Dit is één van de redenen waarom gettext tot leven werd geroepen.

Bij het gebruik van gettext markeert men in de broncode welke strings er vertaald moeten worden. Bij de angular-gettext module gebeurt dit door een translate directive. Bijvoorbeeld.
\begin{lstlisting}[language=html]
<div class="mycontent">
	<h1 class="heading"><translate>hello</translate></h1>
</div>
\end{lstlisting}
Hier wordt aangeduid dat de inhoud van de hoofding met de inhoud "hello" vertaald kan worden. Nadat dit met iedere te vertalen tekst in de broncode is gebeurd, kan men overgaan tot het "extraheren" van de strings. Bij angular-gettext gebeurd dit via een Grunt task. Deze ziet er als volgt uit.
\begin{lstlisting}
module.exports = function(grunt) {
	grunt.initConfig({
		pkg: grunt.file.readJSON('package.json'),
		nggettext_extract: {
			pot: {
				files: {
					'po/template.pot': [
						'public/partials/*.html',
						'public/partials/forms/*.html'
					]
				}
			}
		},
		nggettext_compile: {
			all: {
				files: {
					'public/translations.js': ['po/*.po']
				},
				options: {
					module: 'seanclogApp'
				}
			}
		}
	});
	grunt.loadNpmTasks('grunt-angular-gettext');
	grunt.registerTask('default', ['nggettext_compile']);
};
\end{lstlisting}
Het belangrijke gedeelte is hier alles bij nggettext\_extract. Hier wordt geconfigureerd uit welke bestanden er allemaal translate aanduidingen te vinden zijn. Wanneer al deze bestanden gescand zijn genereert angular-gettext een bestand genaamd template.pot. Dit bevat een template voor het vertalen in andere talen en zal er ongeveer als volgt uit zien. (gegeven het voorbeeld van hierboven).
\begin{lstlisting}
msgid ""
msgstr ""
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Project-Id-Version: \n"

#: public/partials/een_bestand.html:3
msgid "hello"
msgstr ""
\end{lstlisting}
Dit bestand kopieert men naargelang de locale naar waar men wilt vertalen. Indien men bijvoorbeeld een nieuwe vertaling van het programma wilt maken in het Nederlands, kopieert men dit bestand naar "nl.po". Wat men dan moet doen is op iedere regel met een msgstr de vertaling geven van de bovenliggende msgid. Bijvoorbeeld
\begin{lstlisting}
msgid ""
msgstr ""
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Project-Id-Version: \n"

#: public/partials/een_bestand.html:3
msgid "hello"
msgstr "hallo"
\end{lstlisting}
Voor deze laatste stap is geen enkele kennis over ICT vereist. Dat is nu juist de kracht van GNU gettext. Het koppelt de vertaling los van de programmeercode. Vertalers hoeven niet in de programmeercode te kijken om een vertaling te maken de programmeur moet niet aan zijn code sleutelen om een nieuwe vertaling toe te passen.

Vertalingen hebben alleen is niet genoeg. De gebruiker moet ook nog de mogelijkheid hebben tot het kiezen van zijn taal. Bij deze applicatie gebeurd dat via het loginscherm. Onderaan de pagina staat een selectbox. Wanneer de gebruiker hierin een andere taal selecteert gaat er een angular event af die de huidige taal veranderd naar de gekozen taal. Diezelfde functie zet ook een nieuwe cookie met daarin de gekozen taal. Op die manier wordt, wanneer de gebruiker de site opnieuw bezoekt, de site gepresenteerd in dezelfde taal als de vorige keer.

\begin{lstlisting}
seanclogusers.controller('LoginController', ['$scope', '$cookies', 'Login', '$location', 'gettextCatalog', 'User',
function($scope, $cookies, Login, $location, gettextCatalog, User){	
	$scope.setLanguage = function(toset) {
		$cookies.lang = toset;
		gettextCatalog.setCurrentLanguage(toset);
	};
}]);
\end{lstlisting}

\subsection{Animaties}
Omdat de meeste gebruiker een niet actieve website maar saai vinden zijn er aan deze applicatie enkele animaties toegevoegd. Dit is mogelijk via gewone CSS3 tezamen met AngularJS. AngularJS voorzien namelijk vele "hooks" bij zijn directives waarmee bepaalde animatie kan worden toegepast.\cite{angular:animations}

Deze "hooks" kunnen onder andere worden toegepast op containers die van inhoud kunnen veranderen. In deze applicatie gebruiken we een grote container via de directive ng-view. Dit is de container waar onze views in terechtkomen. Ook deze directive heeft ondersteuning voor animaties en we kunnen deze gebruiken om de overgang vlot te laten verlopen tussen de verschillende views.
\begin{lstlisting}[language=css]
.myfade {
	-ms-transition: 1s;
	-moz-transition: 1s;
	-webkit-transition: 1s;
	transition: 1s;
}

.myfade.ng-enter {
	opacity: 0;
}

.myfade.ng-leave {
	opacity: 1;
}
\end{lstlisting}
We wijzen onze ng-view toe aan de klasse myfade. Op deze klassen passen we een overgang toe die exact één seconde gaat duren. Dit doen we door het transition keyword. Omdat ng-view angular animatie ondersteunt krijgt deze de klasse ng-enter wanneer er een nieuwe view binnengegaan wordt en ng-leave waneer er een oude view verlaten wordt. In het geval dat angular de klasse ng-leave toepast komt de opacity op één te staan, anders op nul

%\subsection{Filtering}
%Wanneer de gebruiker teveel data heeft opgeslagen, kan de het een beetje onoverzichtelijk beginnen worden. Daarom heb ik de front-end voorzien van een handige zoek functie. De gebruiker typt een tekst in en het systeem zoekt op basis hiervan tussen de gegevens van de huidige view.
%
%Voor de implementatie hiervan heb ik besloten om uitsluitend native javascript te gebruiken. Angular zelf heeft hier ook een zogenaamde "filter" ingebouwd, maar die was ontoereikend. Deze filter werkt door gebruik te maken van een variabele in de scope als predicaat. Onze applicatie is zodanig gebouwd dat er voor iedere view dezelfde knop en invoerveld wordt gebruikt voor het ingeven van een zoekopdracht. Dit wordt gedaan door middel van "partials". Deze partials worden geladen door het gebruik van de angular ng-include directive. Dit creëert een aparte scope, waardoor het predicaat ontoegankelijk is voor de getoonde data.

%Geef hier voorbeeld

\section{handleiding}

\section{Zelfevaluatie}

\bibliographystyle{alpha}
\bibliography{tex}
\end{document}
