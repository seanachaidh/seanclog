%resumé pour le project seanclog
%Auteur: Pieter Van Keymeulen
%Titre: Seanclog: Simple and Fancy timetracker

\documentclass[a4paper,11pt]{article}

\usepackage[dutch]{babel}
\usepackage{listings}
\usepackage{color}
\usepackage{graphicx}
\usepackage{placeins}
\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{
   language=JavaScript,
   backgroundcolor=\color{lightgray},
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
   numbers=left,
   numberstyle=\footnotesize,
   numbersep=9pt,
   tabsize=2,
   breaklines=true,
   showtabs=false,
   captionpos=b
}
%Een commando voor een mooie tabelhoofding
\newcommand{\head}[1]{\textnormal{\textbf{#1}}}

\begin{document}
\title{Seanclog: Simple and Fancy timetracker}
\author{Pieter Van Keymeulen}
\maketitle

\section{Inleiding}

\subsection{Tijd. Planning. Al het andere}
Dit project heeft zijn oorsprong in mijn eigen persoonlijkheid. Als je het mijn
vrienden zou vragen of ik een ordelijke planner ben, zouden die allemaal
éénzelfde antwoord geven. Een gezamenlijk neen. Omdat ik er vrijwel continu aan
herinnerd wordt, wou ik dit probleem aanpakken. Ik ben programmeur, en het
typische aan dit beroep is dat men ordelijk moet kunnen plannen. Een knelpuntje
voor mij dus. Ik kreeg vaak veel software toegewezen om mij hierbij te helpen.
Veel van deze software ben ik uiteindelijk beginnen gebruiken. Soms hou ik van
deze software, en soms haat ik deze software. Bij de software die ik haat heb
ik, als programmeur, altijd de neiging om deze te willen verbeteren.

Hierbij begon ik een specifieke haat te ontwikkelen voor timetrackers

\subsection{Het probleem?}
Een programmeur wilt natuurlijk op tijd betaald worden. De programmeur wordt
gehuurd, krijgt een opdracht, wordt betaald voor de gepresteerde uren. Maar hoe
moet je nu zo een factuur opstellen. Hoe weet een programmeur nu hoe lang hij
voor een bepaald project heeft gewerkt en nog belangrijker, hoe weet de klant
dat hij een goede, eerlijke prijs betaald voor de afgeleverde software? Je kan
uren spenderen aan het invullen van spreadsheets. Die naar uw klanten sturen.
Verwachten dat uw klant deze zal opmerken. Dat terwijl de klant in kwestie zelf
onder honderden mails bedolven zit en uw mail niet eens opmerkt.

\subsection{Het licht gezien!}
Na heel lang zoeken heb ik uiteindelijk de oplossing gevonden. Wanneer er geen
enkele goede oplossing ter beschikking staat rest de meesten slechts één ding.
Maak het zelf. Met dit project heb ik het doel om een timetracker te maken die
alle eigenschappen die ik aan timetrackers haat niet heeft. Hoofdzakelijk houdt
dit het volgende in.
\begin{itemize}
  \item Minder manueel invoeren
  \item Offline toegang
  \item Toegang vanop meerdere apparaten
  \item Een interface met zo weinig mogelijk afleiding
  \item Gemakkelijke filtering van ingevoerde tracks
\end{itemize}
\section{Gebruikte software}
%Voor dit project werd er bijna uitsluitend gebruik gemaakt van experimentele
%technologie. Tegenwoordig worden webapplicaties vaak ontwikkeld op de zogenaamde
%LAMP stack. Dit is een collectie software die meestal gebundeld gedistribueerd
%wordt omdat ze tezamen de gebruiker in staat stellen tot het hosten van een
%webapplicatie. De LAMP stack bestaat uit vier onderdelen.
%
%\begin{description}
%\item[Een Linux server] Dit is het besturingssysteem waarop de applicatie zal
%draaien
%\item[Apache] Dit is een daemon die het http protocol implementeert. Het stelt
%ons in staat tot het ontvangen en het verwerken van http requests.
%\item[Een MYSQL databank] Dit is te gebruiken databank bedoeld voor het oplaan
%van data. Dit kan gaan om klantengegevens en productgegevens. Andere databanken
%zoals postgresql zijn ook mogelijk, maar bij een LAMP stack gaat het specifiek
%om MYSQL.
%\item[PHP] De programmeertaal die gebruikt wordt voor het maken van de
%applicatie.
%\end{description}
%
%Deze LAMP stack wordt al jaren op deze manier gebruikt. Het is vrij oude
%technologie die al jaren meegaat en bijgevolg dus enorm betrouwbaar is. Het
%heeft echter een aantal zwakke punten.
%
%\begin{itemize}
%  \item Het onderhoud van een linux server is een tijdrovende bezigheid.
%  \item Apache is een modulair programma. Men kan functionaliteit toevoegen en
%  verwijderen. Veel van de functionaliteit staat standaard aan of kan zelfs
%  helemaal niet verwijderd worden. Dat terwijl de meesten niet zoveel
%  functionaliteit nodig hebben. Daarbij kan het ook ervoor zorgen dat Apache
%  onveiliger wordt en gemakkelijker is om in in te breken.
%  \item MYSQL heeft veel limitaties. We leven in een wereld waarin data alsmaar
%  meer aandacht krijgt. Bedrijven verzamelen, analyseren en gebruiken. Dit
%  allemaal om hun klantenervaring zo veel mogelijk te kunnen verbeteren.
%\end{itemize}

Voor dit project wordt er gebruik gemaakt van de MEAN-stack. Dit is variant op de LAMP stack. De LAMP stack wordt tegenwoordig het meest gebruikt. De MEAN stack daarentegen is een vrij jong concept. Veeleer omdat de MEAN stack uitsluitend uit nieuwe technologie bestaat.

De MEAN stack is een collectie van software die er voor zorgt dat men de mogelijkheid heeft een webapplicatie te ontwikkelen. Deze MEAN stack bestaat uit de volgende onderdelen

\begin{description}
\item[MongoDB] Dit is een niet-relationele databank. In plaats van de data voor te stellen als relationele tabellen gaat men de data voorstellen als een collectie van documenten. Ieder document is een JSON object. JSON formaat dat dezelfde stijl als javascript gebruikt om objecten op te slaan.
\item[Express] Express is een nodejs framework waarmee makkelijk webapplicaties in nodejs kunnen worden gemaakt. Het voor ziet voornamelijk een manier om routes te programmeren binnen je applicatie alsook het toevoegen van middleware.
\item[AngularJS] AngularJS is een javascript framework die de gebruiker in staat stelt om via javascript client-side een MVC patroon toe te passen. Dit doen ze door het voorzien van controllers, views en services. Meer informatie hierover later
\item[NodeJS] Dit is een javascript interpreter die zonder browser werk. In plaats hiervan wordt de google V8 engine gebruikt om javascript code uit te voeren. Dit stelt ons in staat om javascript ook server side te gaan gebruiken. In tegenstelling tot veel andere programmeertalen, werkt file input/output volledig nog blocking. Hierdoor is het perfect voor het maken van webapplicaties omdat op die manier meerdere requests tegelijkertijd afgehandeld kunnen worden.

\end{description}

\subsection{Nodejs}
Nodejs is een javascript interpreter die in tegenstelling tot andere javascript interpreters niet gekoppeld is aan een webbrowser. Men kan hiermee javascripts uitvoeren alsof het gewone programma's zouden zijn. Dit heeft als neveneffect dat het ook gebruikt kan worden voor bijvoorbeeld server side scripting.

Eigenlijk is het ook niet correct om NodeJS een interpreter te noemen. NodeJS gebruikt immers google's v8 javascript engine. Waarin deze engine zich onderscheid van de andere engines is dat de code eerst wordt gecompileerd naar machinecode voor het wordt uitgevoerd. Hierdoor is er geen echt interpreting proces zoals bijvoorbeeld bij php het geval is.

Dit is echter slecht één van de redenen waarom het een handige tool is voor het gebruik bij server side scripting. Tegenwoordig worden er alsmaar meer webapplicaties gebouwd. De bedrijven die deze webapplicaties bouwen hebben alsmaar meer klanten. Al die klanten moeten tegelijk afgehandeld worden. Computers hebben echter hun limieten. Wanneer een gebruiker een webpagina zou opvragen, betekend dat dat deze gebruiker een html bestand doorgestuurd zal moeten krijgen. Dat HTML bestand dient ingelezen en doorgestuurd te worden. Wanneer het besturingssysteem een bestand inleest betekent dat dat deze een zogezegde lock op dat bestand legt. Enkel het proces dat de leesbewerking heeft aangevraagd, mag het bestand inlezen. Van zodra dit proces gedaan heeft met lezen, wordt deze lock vrijgegeven en is het de beurt aan het volgende proces. Wanneer één van de processen die aanspraak willen maken op het bestand, nadat hij deze aanspraak gekregen heeft, in een lus gaat. Vormt dit een dead-lock. Dit wil zeggen dat alle input en output met betrekking tot dit bestand stilvalt en niemand meer aan het bestand kan. Het hele proces valt stil.

In NodeJS zijn er echter geen locks.

\subsection{MongoDB}
MongoDB is, in tegenstelling tot traditionele SQL databanken, een 
no-sql databank. Dit wil zeggen dat de data niet voorgesteld wordt door 
tabellen. Hoe de data dan wel voorgesteld wordt, wordt in de definitie 
van no-sql niet vervat. Over het algemeen wordt bij een gewone mysql 
databank, een collectie aan data voorgesteld door een tabel. Bij een 
nosql gaat men uit van andere metaforen die ieder beter bij het 
werkveld passen waarvoor de databank specifiek ontworpen is. Stel nu 
dat ik een complexe hiërarchie binnen een bedrijf als gegeven heb. 
Iedere werknemer van dit bedrijf heeft contacten, die op hun beurt 
contacten hebben, die op hun beurt alweer contacten hebben. Dan zou 
het leuk zijn mocht ik al de relaties die deze werknemers met elkaar 
hebben op een efficiënte manier kunnen ophalen. Wanneer men vasthoudt 
aan de klassieke tabel metafoor is dit echter heel moeilijk, maar 
wanneer we de relaties op één of andere manier op voorhand in de data 
kunnen programmeren, dan wordt het ineens een stuk makkelijker.
dat ik  Over het algemeen kan men spreken over de 
volgende types nosql databanken

\begin{description}

\item[Column] Hierbij wordt er bij het persisteren van data de nadruk geleld op de kolom in plaats van de rij. %Dit moet ik beter uitleggen
\item[Document] Hierbij wordt ieder stukje data, neem nu bijvoorbeeld 
een student, voorgesteld als een document. In dit document zit dan alle 
data vervat die een student moet voorstellen.
\item[Key-value] Hierbij wordt iedere waarde die geschreven wordt naar de databank voorgesteld door middel van een sleutel. Later kan in de applicatie naar die sleutel gerefereerd worden.
\item[Graph] Hierbij worden de gegevens voorgesteld door een graaf. Dit soort databank legt minder focus op de gegevens op zich, maar eerder op de relaties die de gegevens onderling hebben. %Hier een afbeelding van een graaf ingooien
\end{description}

Gezien dat er in deze applicatie eerder gebruik wordt gemaakt van een document-georiënteerde databank, gaat de focus van dit document hier voornamelijk naar uit. Zoals hierboven al is uitgelegd geweest stelt een document-georiënteerde databank, zoals MongoDB, de data voor als een collectie van documenten. Deze documenten kunnen in alle mogelijke vormen komen. XML, JSON, YAML, of zelfs gewoon een binaire blob. In wezen zou men zo document-georiënteerde databank in de vrij letterlijke zin kunnen gebruiken en er scans van bijvoorbeeld facturen in opslagen die dan verzameld worden in de collectie "facturen". In het geval van MongoDB worden documenten uitsluitend in het JSON format opgeslagen, of beter gezegd, BSON, wat MongoDB zijn eigen binaire variant is van JSON. Het gebruik van JSON heeft vele voordelen tegenover het gebruik van traditionele relationele tabellen.  Met JSON kan men immers een object nesten in ander object. Dit is vooral nuttig wanneer bepaalde gegevens altijd tezamen worden gebruikt. Stel nu dat men de gegevens van een werkgever zou bewaren. Dan wilt men meestal ook het adres van deze werknemer bewaren. Vanwege de enorme hoeveelheid kolommen dat adresgegevens gewoonlijk in beslag nemen, wordt dit meestal in een andere tabel gestoken. De persoonsgegevens en het gekoppelde adres worden echter altijd tezamen gebruikt, maar bij relationele systemen moet hier telkens een JOIN clausule worden gebruikt waar naar beide tabellen wordt gerefereerd om uiteindelijk de twee tabellen samen te voegen. Dit is enorm veel schrijfwerk. Zeker als die JOIN in tachtig procent van de gevallen gebruikt wordt.

In MongoDB kan men dit allemaal vermijden. Wanneer men een werknemer in de databank aanmaakt kan men in MongoDB het adres van die werknemer opslaan als een object dat een werknemer "bezit". Het uiteindelijke JSON-object is dan als volgt.

\begin{lstlisting}[language=javascript]
{
	naam: James bond,
	werknemerid: 007
	adres {
		straat: to expensive yacht,
		nummer: 666,
		city: caribbean sea
	}
};
\end{lstlisting}

Tegenwoordig wordt er nog steeds veelvuldig gebruik gemaakt van relationele databanken. Er is echter een grote verschuiving gaande ten voordele van de niet relationele databanken. Deze verschuiving is begrijpelijk omdat laatstgenoemde veel meer voorzien is op het verwerken van grote hoeveelheden data. Sinds vijf jaar geleden hebben sociale netwerken almaar meer belang gekregen in onze samenleving. Deze worden voor diverse dingen gebruikt. Foto's delen, documenten delen, ervaringen delen. Veel van deze applicaties bieden al deze diensten aan binnen één platform. Vroeger was het de gewoonte dat iemand een aparte provider gebruikte voor zijn email, om te chatten, om te bloggen, om foto's te delen. In de laatste vijf jaar is het internet echter meer gecentraliseerd geraakt waardoor één organisatie een enorme hoeveelheid data beheert. Neem daarbij dat we met almaar meer mensen op deze wereld leven die almaar vaker toegang hebben tot ICT en het plaatje is compleet.

Omdat relationele databanken nog steeds veel gebruikt worden is het handig om hier een analogie te scheppen tussen relationele databanken en MongoDB

\begin{tabular}{lcr}
\hline
\head{Begrip} & \head{Relationele databank} & \head{Mongo} \\
\hline
Verzameling & Tabel & Collection \\
Element van deze verzameling & Row & Document \\
Een attribuut van een element & column & field

\end{tabular}

Men kan in Mongo, net zoals in SQL, verwijzen naar andere documenten. Wanneer er een nieuw document wordt aangemaakt wordt deze hetzij impliciet, hetzij expliciet voorzien van een ID. Dit ID kan als waarde voorkomen de velden van andere documenten. Men moet bij deze methode op enkele dingen letten. MongoDB is zo simpel mogelijk ontworpen en legt zelf heel weinig restricties op. Alle validatie van data wordt overgelaten aan de applicatie. MongoDB gaat onder meer geen types opleggen aan de velden van een document. Ieder veld kan ieder type bevatten dat Mongo ondersteunt. Dit wilt zeggen dat een veld genaamd datum niet zozeer een datum hoeft te bevatten en dat ook andere objecten met hetzelfde veld iets anders kunnen bevatten dan een datum. Ook het aantal velden wordt op databankniveau niet opgelegd. Het ene document van een collectie kan 10 velden bevatten en het andere 20.
\subsubsection{GridFS}
Een extraatje van MongoDB waar in deze applicatie geen gebruik van wordt gemaakt heet GridFS. Eerder ging het erover dat bij een document-georiënteerde databank, een gegeven ieder type bestand kan zijn. Dit kan gaan om afbeeldingen, muziek, of, in het geval van Mongo, om JSON documenten. Documenten kunnen maximum 16MB groot zijn. Dus zelfs al zou men iets anders willen bewaren dan een JSON-object. Dan zou het nog niet lukken. Of niet? MongoDB heeft hier namelijk een oplossing voor, genaamd GridFS. GridFS laat toe om andere types documenten op te slaan in plaats van een JSON-objecten. Deze andere documenten kunnen eventueel alsnog vergezeld worden door enkele JSON gegevens. Dit komt omdat GridFS bedoeld is om documenten op te splitsen over meerdere collecties. Wanneer het document opgevraagd wordt, stel MongoDB het document opnieuw samen.

\subsection{Express}
Express is een bibliotheek die het maken van webapplicaties met nodejs vergemakkelijkt. Het vormt een extra laag bovenop nodejs. Het ondersteunt verschillende features. De feature waar wij het meest gebruik van gaan maken is de routing feature. Dit laat ons toe om routes te maken. Dit wil zeggen dat men een bepaalde url gaat koppelen aan een functie in JavaScript. Wanneer er dan naar deze url gesurft wordt, wordt deze functie uitgevoerd. Meestal worden er dan dingen uit de databank opgehaald naargelang de parameters die bij het request worden meegegeven. Daarna sturen we dat resultaat terug als een JSON Object

\subsection{AngularJS}
%nog uit te leggen
%	scopes.

Voor dit project gaan we gebruik maken van AngularJS. Dit is een javascript framework bedoeld voor het vergemakkelijken van een Model View Controller webapplicatie. In tegenstelling tot vele andere model-view-controller frameworks voor webapplicaties, is AngularJS volledig geschreven in JavaScript. Dit heeft tot gevolg dat de applicatie volledig client-side kan werken. Dit heeft dan weer het voordeel dat de applicatie veel sneller zal draaien omdat er minder requests nodig zijn naar de server. Het Angular framework is volledig modulair opgebouwd. Een Angular applicatie bestaat typisch uit enkele modules. Deze modules kunnen verspreid zijn over meerdere bestanden. Wanneer men een applicatie opstart moet men meegeven welke moduels de applicatie precies gebruikt. Dit gebeurd als volgt.

\begin{lstlisting}[language=javascript]
var var seanclogApp = angular.module('seanclogApp',
		['seanClogServices', 'seanClogControllers', 'ngRoute', 'ui.grid',
		 'pascalprecht.translate']);
\end{lstlisting}

Zoals u zelf waarschijnlijk zult merken is de applicatie zelf ook een module. Dit module systeem heeft zijn voordelen. Stel dat men de controllers van een de ene applicatie wilt gebruiken in een andere. Dan hoeft men enkel het bestand dat deze module bevat te kopiëren naar de broncode van de andere applicatie. Als dat gedaan is en het bronbestand geladen wordt door één van de webpagina's van uw applicatie moet men deze module registreren door deze aan de applicatie toe te voegen. Dit gaat als volgt.

\begin{lstlisting}[language=javascript]
var seanclogApp = angular.module('seanclogApp',
		['seanClogServices', 'seanClogControllers', 'ngRoute', 'ui.grid',
		 'pascalprecht.translate', 'mijnNieuweModule']);
\end{lstlisting}

In dit voorbeeld staat "mijnNiueweModule" voor de module die u zopas heeft toegevoegd.

\subsubsection{Views}
Omdat deze applicatie het model view controller design pattern gaat volgen gaan we ook gebruik maken van views. Deze views worden beheerd door AngularJS. Wanneer de gebruiker naar de root van onze applicatie navigeert (dit wil zeggen http://mydomain.com/) levert de applicatie zoals gewoonlijk een html pagina geleverd genaamd "index.html". Dit is echter meteen de enige echte webpagina die de gebruiker zal ontvangen. De rest zit vervat in code die samen verzonden wordt met de webpagina. Deze code beslist welke views er op welk moment getoond moeten worden.

Deze pagina ziet er als volgt uit
%FIXME: Ik gebruik hier geen tags, maar attributen
\begin{lstlisting}[language=html]
<html>
	<head>
		<!-- hier zetten we alle scripts die nodig zijn voor het draaien van de applicatie -->
	</head>
	<body>
		<div ng-view> <!-- hier komen de views --></div>
	</body>
</html>
\end{lstlisting}
Deze views zijn niets meer dan gewone webpagina's die tussen de broncode geworpen worden, op de plek waar de ngview tag staat. Deze code wordt dan in zijn geheel verwerkt door de webbrowser. De views kunnen bestaan uit één of meerdere subviews. Deze subviews kunnen worden toegevoegd door het gebruik van de ng-include tag. Stel dat men de volgende view heeft:
\begin{lstlisting}[language=html]
<div id="myview">
<p>Dit is een test</p>
</div>
\end{lstlisting}
Dan zou men hier code uit een ander bestand er aan kunnen toevoegen.
\begin{lstlisting}[language=html]
<div id="myview">
<p>Dit is een test</p>
<div ng-include="'/partials/view2'"
</div>
\end{lstlisting}

\subsubsection{Controllers}
%hier schrijven over het opsplitsen van de controllers
%Iedere resource heeft zijn eigen controller en door middel van het angular modulesysteem zetten we iedere
%controller in een eigen bestand. Op die manier blijft onze code ordelijk.

Wat betreft de controllers heb ik besloten om volledig gebruik te maken van Angulars kracht. Het modulaire systeem van AngularJS staat de programmeur toe om het programma in meerdere bestanden op te splitsen zolang men deze javascripts maar laad in de applicatie. Dit rekeninghoudend met de afhankelijkheid tussen de modules onderling.

Ik heb ervoor gekozen om voor iedere resource een controller te voorzien. Dit is in de meeste gevallen de aangewezen methode bij het maken van applicaties in het Model View controller patroon %Leg uit wat model view controller is.
Dit wil zeggen dat mochten we een resource genaamd klanten hebben, ik de applicatie ga voorzien van een controller genaamd klanten waarin alle procedures voor het afhandelen van informatie omtrent klanten, in zit vervat.  Dit gaat onder meer over bewerken, verwijderen, maken, plus nog enkele mogelijke hulpfuncties.

\subsubsection{Services}
Het ophalen van data van de database door de client gebeurt door middel van services. Services zijn een concept binnen AngularJS en kunnen gezien worden als singletons. Een service wordt gemaakt door de factory methode op te roepen van de het applicatieobject. Dit krijg twee parameters mee. De eerste parameter is een naam. Deze naam zal later gebruikt worden om naar onze service te kunnen refereren. De tweede parameter is een functie die een object hoort terug te geven. Dit object kan allerlei dingen bevatten. Variabelen, functies, het is kortom een volwaardig object. De bedoeling is dat dit object vanaf elke plek binnen onze applicatie beschikbaar zal zijn. We kunnen deze services in andere modules gebruiken. Bij het maken van een module moet er namelijk een array doorgegeven worden. Deze array is een lijst met strings. Deze strings zijn namen van services. Zo weet angular welke services in een module worden gebruikt. De genoemde services moeten daarna enkel als parameter genoemd worden in de functie gekoppeld aan de module. Daarbij zijn ze ook nog eens lui geïnitialiseerd. Dit wil zeggen dat Angular deze objecten enkel aanmaakt wanneer ze echt worden gebruikt. Men kan bijvoorbeeld een module laden waarin een service vervat zit, maar waarvan geen gebruik gemaakt wordt. Mocht deze service toch geïnitialiseerd worden, neemt deze onnodig plek in het geheugen en kan deze de applicatie nodeloos vertragen. Door deze techniek kan Angular sneller werken en hebben Angular applicaties een lagere memory-footprint.

De volgende voorbeeldcode stelt een service voor die toegang geeft tot de "Klant" route. De gekoppelde functie maakt een zogenaamd resource object aan. Dit is een object dat bij creatie een URI ontvangt (meestal is dit een route van een RESTAPI) en daarna enkele methodes maakt die een request versturen naar deze URI. Deze methodes zijn analoog met de REST methodes.
\begin{lstlisting}

seanclogclient.factory('Klanten', [ '$resource', function($resource) {
	var fact = $resource('/api/clients/:id', {}, {
		'query' : {
			method : 'GET',
			isArray : true
		},
		'post' : {
			method : 'POST',
			params : {}
		},
		'remove': {
			method: 'DELETE',
			params: {}
		},
		'update': {
			method: 'PUT',
			params: {}
		}
	});
	return fact;
}]);

\end{lstlisting}

Normaal gezien worden deze methodes impliciet aangemaakt. Men kan deze methodes echter ook expliciet aanmaken, zoals in het bovenstaande voorbeeld. Dit laat de programmeur toe om enkele standaard opties aan te passen.

\subsubsection{Filters}
%Hier schrijven over de datumfilter die ik heb gemaakt.

\subsubsection{Directives}
%Het is niet de naam maar de ng-model
Voor het maken van deze applicatie heb ik het voorzien van één custom directive genaamd ng-match. Deze zorgt ervoor dat de inhoud van het éne invoerveld overeenstemt met het andere. Stel dat men een formulier heeft en dat formulier heeft een invoerveld genaamd wachtwoord. Dan kan men de gebruiker dwingen dezelfde tekst in een tweede invoerveld te schrijven door dat invoerveld te voorzien van het ng-match attribuut, met als waarde dezelfde als de naam van het eerste invoerveld. Wanneer de waarde van het tweede invoerveld niet overeenstemt met de waarde van het eerste is de waarde niet geldig en wordt deze niet opgestuurd naar de server.

\begin{lstlisting}[language=javascript]
seanclogSecurity.directive('ngMatch', ['$parse', function($parse) {
	//ngmatch directive
	
	function link(scope, elem, attrs, ctrl) {
		if(!ctrl) return;
		if(!attrs['ngMatch']) return;
		
		var firstPassword = $parse(attrs['ngMatch']);
		
		var validator = function(value) {
			var temp = firstPassword(scope);
			var v = (value === temp);
			ctrl.$setValidity('match', v);
			return value;
		};
		
		ctrl.$parsers.unshift(validator);
		ctrl.$formatters.push(validator);
		attrs.$observe('ngMatch', function() {
			validator(ctrl.$viewValue);
		});
	}
	
	return {
		link: link,
		restrict: 'A',
		require: '?ngModel'
	};
}]);
\end{lstlisting}

\subsubsection{Data validatie}
%Nagaan of de required direcitve wel degelijk iets van angular is
Men kan er niet altijd op vertrouwen dat de gebruiker de data op de juiste manier invoert. Om er zeker van te zijn dat er valide gegegevens ingegeven worden in de formulieren gaan we de gebruiker hier dus in bijstaan en validatie toepasssen. AngularJS heeft hiervoor enkele systemen ingebouwd. Het is mogelijk om binnen een formulier, velden aan te duiden die noodzakelijk zijn. Stel dat men bijvoorbeeld een klant wilt aanmaken. Dan heeft die klant een naam nodig. We kunnen die als volgt adwingen
\begin{lstlisting}[language=html]
<input type="text" ng-model="klant.naam" class="form-control" required />
\end{lstlisting}

We kunnen ook een bepaald type invoer afdwingen. We kunnen ervoor zorgen dat de gebruiker enkel nummers kan invoeren. Dit doen we door het type-attribuut van text naan number te veranderen.

Wanneer een invoerveld binnen een formulier niet geldig blijkt te zijn, zal Angular dit invoerveld toewijzen aan de klasse "ng-invalid". Als programmeur kan ik dan op deze klasse enkele stijlen toepassen die er bijvoorbeeld voor zorgen dat niet geldige invoervelden rood kleuren. Hetzelfde gebeurd met geldige invoervelden door middel van de "ng-valid" klasse. Verder krijgt een formulier in AngularJS een aantal extra objecten mee. Eén van die objecten is een object genaamd \$error. Dit object bevat informatie over welke invoervelden er op dat moment geldig zijn en welke niet. Stel dat men een invoerveld heeft met de naam "email". Wanneer dit invoerveld de text "blahblah" bevat zal het object "myform.email.\$error.eamil" de waarde true bevatten.


\section{Interne structuur} %hier heb ik wikipedia als bron gebruikt
De meeste applicaties zijn bedoeld voor het persisteren en het beheren van bepaalde gegevens. In sommige gevallen zijn dat gegevens van studenten. In ons geval zijn dat gegevens van klanten, projecten en tracks. Een computer kan hoofdzakelijk alleen wiskunde. Men zegt vaak dat een computer heel slim is, maar met alleen wiskunde kom je er in het leven. Wat we wel kunnen doen is de werkelijkheid proberen herleiden tot wiskunde. We kunnen de het gegeven dat wij willen bereiken op een zodanige manier noteren dat dit voor een computer begrijpbaar wordt. Hiervoor zijn programmeertalen erg handig. Ze laten ons toe om onszelf uit te drukken tegenover een computer. Als we alle gegevens op die manier zouden uitdrukken zouden we het volgende schema moeten bekomen.

\begin{center}
\begin{minipage}{\linewidth}
\centering
\includegraphics[scale=0.5]{model}
\end{minipage}
\end{center}

Het model van de applicatie is redelijk minimalistisch. Helemaal bovenaan staat de Gebruiker. Daarnaast heeft men alle soorten data waarmee die met de gebruiker geassocieerd kunnen zijn. Deze zijn.
\begin{description}
\item[Klanten] Klanten waarvoor men projecten kan maken.
\item[Projecten] Projecten die men voor een klant maakt. Deze projecten zijn verbonden aan tracks
\item[Tracks] Een bepaalde tijdspanne die men aan een project heeft gespendeerd.
\item[Token] Een validatietoken voor een gebruiker.
\end{description}

\subsection{RestAPI}
%Hier bespreken wij de RESTAPI
%Wij gaan voor deze applicatie gebruik maken van een RESTFUL api. Dit zorgt
%ervoor dat we makkelijk meerdere clents kunnen maken die ook op op desktops
%werken, telefoons, misschien zelfs een tv. De mogelijkheden zijn nagenoeg
%eindeloos.
%
%RestApi's worden doorgaans gebruikt voor het ophalen en het wegschrijven van
%data. Deze data kunnen uiteenlopende dingen zijn. Afbeeldingen, blogartikels,
%zelfs volledige objecten. Deze RestApi is meestal toegankelijk via het HTTP
%protocol. Dit zorgt ervoor dat het makkelijker is om clients te maken die deze
%API kunnen gebruiken omdat HTTP een alomvertegenwoordigd protocol heeft. Het is
%een protocol dat standaard in praktisch iedere networking api geïmplementeerd is
%en dat als dus danig door vele computers begrepen wordt.
%
%Elk type data (of resource) wordt voorgesteld door een uniform resource
%identifier (ofwel URI)
%
%Een RESTApi bestaat uit de volgende componenten.
%\begin{description}
%  \item [Get] Een get request
%  \item [Delete] Verwijder data
%  \item [Put] Verander data
%  \item [Post] Bewaar data
%\end{description}

Voor de ontwikkeling van de service werd er gekozen voor een RESTAPI. Een belangrijk gegeven dat men moet begrijpen bij het maken van een RESTAPI, is dat REST slechts een aantal regels zijn. Deze regels worden toegepast op het ontwerp van alle componenten van de applicatie om zodoende een schaalbare internetdienst te verkrijgen. Zo een dienst communiceert over het internet via het HTTP protocol door middel van de standaard HTTP methodes GET, POST, PUT, DELETE. Dit zijn de gewone standaard methodes die webbrowsers gebruiken voor het verkrijgen en verzenden van informatie via het internet

Indien men de regels van een RESTAPI op een goede manier toepast, kan men een website met de volgende eigenschappen bekomen.

\begin{description}
\item[Schaalbaar] Een oneindig aantal componenten kan worden ondersteunt die met elkaar kunnen communiceren. Dit aantal componenten is ook uitbreidbaar tot in het oneindige.
\item[Simpelheid] De REST-architectuur zit heel simpel in elkaar, slechts gebruik makend van bestaande protocollen.
\item[Beheerbaarheid] Een RESTAPI is over het algemeen gemakkelijk te beheren. Er kan op ieder moment in de ontwikkeling een component worden toegevoegd, verwijderd of geüpdatet.
\item[Zichtbaarheid] De communicatie tussen client en server is zichtbaar voor programma's die het eventueel willen opvolgen. Tenzij er gebruik gemaakt wordt van https.
\item[Portability] Een service is gemakkelijk overzetbaar van de ene server op de andere server
\item[Betrouwbaarheid] Men kan de webserver die de API aanbiedt gemakkelijk zodanig afstellen dat er na 5 aanvragen gestopt moet worden met proberen. 
\end{description}

Een belangrijk basisprinciepe van REST is dat het resourcegebasseerd is. Iedere entiteit wordt door exact één enkele resource identifier voorgesteld. Op deze identifier worden dan de betrokken methodes PUT, DELETE, POST en GET uitgevoerd. Wanneer er een request wordt verstuurd naar de server wordt er een "representatie" van deze resource teruggestuurd in plaats van de resource zelf. De server gaat niet de databank verzenden, maar een tekst in de vorm van JSON, XML en anderen. Dit gefilterd door middel van de parameters die meegegeven werden tijdens de aanvraag.

De resources op de server worden ook bewerkt door middel van deze presentaties. Dit wil zeggen dat, wanneer een client een resource wilt aanpassen, deze de resource die hij wilt aanpassen, moet omzetten in een JSON (indien de server gebruik maakt van JSON). Deze informatie kan eventueel nog metadata bevatten. Bijvoorbeeld het identificatienummer van de resource die moet worden aangepast. Deze resource moet worden verstuurd naar de URI van de resource die men wilt aanpassen met de UPDATE methode. De server zal dan de resource aanpassen, op voorwaarde dat deze de rechten hiertoe bezit.

Ieder bericht dat verzonden wordt naar de server bevat genoeg informatie voor het verwerken van dat bericht. Dit wil zeggen dat het bericht voldoende metadata bevat voor de volledige uitvoer. Stel dat men een informatie van een klant zou willen opslagen en die informatie is gekoppeld aan een gebruiker van de applicatie, dan zou het bericht niet alleen de informatie van die klant moeten bevatten, maar ook van de gebruiker en dit op voldoende wijze zodat de gebruiker eraan gekoppeld kan worden.

De status van zowel de server als de client moet verstuurd worden via "bodies" van doorgestuurde data (dit wil zeggen: doorgestuurde json objecten), query strings, request headers en ga zo maar door. Kort gezegd wordt de gehele status van de applicatie doorgegeven via hypermedia.

\subsubsection{URI}
Zoals eerder gezegd wordt bij een RESTAPI de resources voorgesteld door URI's. Deze applicatie volgt hierin een gemakkelijk te volgen structuur. Iedere URI correspondeert met een collectie binnen MongoDB. Men start de URI met "/api/" om aan te geven dat men een oproep op de API wilt doen. Daarna geeft men de collectie op waarop men een bewerking wilt uitvoeren. De collectie projecten wordt bijvoorbeeld aangeduid door projects. Dit geeft "/api/projects". Daarna kan men, afhankelijk van de operatie die men wilt uitvoeren. Stel dat men bijvoorbeeld het project met de ID 12345 wilt bewerken geeft dit "/api/projects/12345". De applicatie ondersteunt enkel de methodes POST, UPDATE, en DELETE op deze manier. Normaal gesproken zou, in een complete RESTAPI dit ook met GET moeten werken. In dat geval zou enkel de resource met het opgegeven ID moet worden teruggestuurd, maar omdat dit nooit in één van de front ends van de applicatie nodig is geweest. Is dit bijgevolg dus nog niet geïmplementeerd. Wanneer dit gedaan is moet er nog een access token voorkomen in de query string. Dit is een token die gekoppeld is aan een gebruiker van de applicatie. Op deze manier wordt er nagekeken of de request legitiem is en of de gebruiker het recht heeft om de bewerking uit te voeren. Uiteindelijk zal men de volgende URI bekomen "/api/projects?access\_token=abcd1234".

\paragraph{/api/users}
Hiermee worden de gegevens bewerkt in de gebruikers collectie. De gebruikers collectie bevat documenten met daarin de gegeven van, logisch, de gebruikers van de applicatie. Dit is onder andere het wachtwoord, de naam, het email adres en dergelijke. Het wachtwoord wordt niet opgeslagen als leesbare tekst. In plaats daarvan slaan we de tekst op met een MD5 codering. MD5 is een algoritme dat vrij tekst kan omzetten naar een tekenreeks die in de verste verte niet op de originele tekst lijkt. Maar telkens wanneer men eenzelfde tekst door het algoritme voert bekomt men dezelfde tekenreeks. Wanneer een gebruiker aanlogt wordt deze tekenreeks vergeleken met datgene wat we hebben opgeslagen in de databank. Op die manier moeten we nooit het echt wachtwoord opslaan. Deze route ondersteunt de volgende methodes.

\begin{description}
\item[GET] Stuurt de gebruikersgegevens terug van de gebruiker die gekoppeld is aan de token meegegeven in de query string
\item[POST] Maakt een nieuwe gebruiker aan.
\item[PUT] Werkt de gebruiker bij die gekoppeld is aan de meegegeven access token. De nieuwe gebruikersgegevens worden meegegeven als JSON object via de requestbody.
\item[DELETE] Verwijdert de gebruiker die gekoppeld is aan de meegegeven access token.
\end{description}

\paragraph{/api/projects/:id}
Hiermee worden de gegevens bewerkt in de "Projecten" collectie. Een project is een werk waar een gebruiker voor een lange tijd aan bezig is en wordt gekoppeld aan een klant. Deze route ondersteunt de volgende methodes.

\begin{description}
\item[GET] Stuurt alle projecten terug van de gebruiker die gekoppeld is aan de meegegeven access token
\item[DELETE] Verwijdert het project gekoppeld aan het meegegeven ID. Ook alle tracks die gekoppeld zijn aan dit project worden automatisch verwijderd.
\item[PUT] Werkt het project bij van de gebruiker gekoppeld aan aan de meegegeven access token. De gegevens die bijgewerkt moeten worden, worden bepaald door het JSON object in de de request body. Het project dat zal worden bijgewerkt is dat project met de ID gelijk aan het ID veld in de request body.
\item[POST] Maakt een project aan voor de gebruiker gekoppeld aan de meegegeven access token. Het project dat aangemaakt moet worden wordt meegegeven als JSON via de request body
\end{description}

\paragraph{/api/clients/:id}
Hiermee worden gegevens bewerkt in de "klanten collectie. Een klant is een bedrijf of een persoon waarvoor een gebruiker een project kan hebben.
\begin{description}
\item[GET] Stuurt alle klanten terug van de gebruiker die gekoppeld is aan de meegegeven access token.
\item[DELETE] Verwijdert de klant met de meegegeven ID op voorwaarde dat deze klant aangemaakt is geweest door de gebruiker die gekoppeld is aan de meegegeven access token. Hiermee worden ook automatisch alle projecten verwijderd die gekoppeld zijn aan de klant die verwijderd wordt.
\item[PUT] Werkt de klant bij met de meegegeven ID. De nieuwe gegevens voor de klant worden meegegeven via de request body in JSON formaat. Deze operatie wordt enkel uitgevoerd als de klant aangemaakt is geweest door de gebruiker die gekoppeld is aan de meegegeven access token.
\item[POST] Maakt een nieuwe klant aan met de gegeven die meegegeven worden in JSON formaat via de request body.
\end{description}

\paragraph{/api/tracks/:id}
Hiermee worden de gegevens bewerkt van de "Tracks" collectie. Een track is één bepaalde tijdspanne die een gebruiker aan één bepaald project spendeert.
\begin{description}
\item[GET] Dit stuurt alle tracks terug van de gebruiker die gekoppeld is aan de meegegeven access token.
\item[POST] Hiermee wordt er een nieuwe track gemaakt. De track die aangemaakt moet worden, wordt meegegeven via de request body in de vorm van een JSON object. De track wordt gekoppeld aan de gebruiker met de meegegeven access token
\item[PUT] Hiermee wordt de track bijgewerkt met de meegegeven ID. De nieuwe gegevens worden doorgegeven als JSON object via de request body. Deze operatie wordt niet uitgevoerd als de gebruiker die gekoppeld is aan de meegegeven access token, geen eigenaar is van de track.
\item[DELETE] Hiermee wordt de track met de meegegeven ID verwijderd. Deze operatie wordt niet uitgevoerd als de gebruiker, gekoppeld aan de meegegeven access token geen eigenaar is van de track.
\end{description}

\paragraph{/api/users/changepassword}
Deze route wordt enkel gebruikt voor het wijzigen van wachtwoorden en reageert slechts op één methode
\begin{description}
\item[PUT] Hiermee wordt het wachtwoord bewerkt van de gebruiker gekoppeld aan de meegegeven access token. Hierbij wordt er een JSON object meegegeven via de request body. Dit JSON object bevat slecht één veld genaamd wachtwoord, met daarin het nieuwe wachtwoord.
\end{description}

\subsection{Beveiliging}
\subsubsection{Tokens}
Het hebben van een goede applicatie betekent niet alleen dat de applicatie er goed uit moet zien. Klanten vertrouwen ons hun gegevens toe. Daarom moeten we erop toezien dat de applicatie goed beveiligd is. Dit hoop ik te bereiken door het gebruik van token based authenticatie. Wanneer een gebruiker zich aanmeldt zouden we alle gebruikers kunnen opsturen. Inclusief het wachtwoord. Wanneer de gebruiker dan data wilt opvragen zou deze terug zijn wachtwoord kunnen opsturen om zijn aanvraag te doen gelden. Dit gaan we echter niet doen. In plaats daarvan gaan we iedere gebruiker een token geven. De bedoeling is dat deze token opgestuurd zal worden in plaats van het wachtwoord. De tokens worden opgeslagen in een aparte collectie tezamen met de een veld waarin de datum staat wanneer de token is gemaakt. Telkens wanneer er een aanvraag afgehandeld wordt, wordt de token meegegeven via de query parameters. Dit wil zeggen de GET paramters. Hierna wordt er naar deze token gezocht. Als deze token bestaat, wordt er gekeken naar de leeftijd van de token. Mocht deze ouder zijn dan zeven dagen wordt er een foutboodschap teruggestuurd. Is dit niet het geval, dan is de aanvraag geautoriseerd en ontvangt de gebruiker zijn gevraagde gegevens. Mocht de token helemaal niet bestaan wordt er tevens een foutboodschap teruggestuurd. Telkens wanneer de token niet bestaat of deze vervallen is dient te gebruiker een nieuwe te genereren door zich opnieuw aan te melden.

\subsubsection{Emailverificatie}
Het is natuurlijk niet handig mochten gebruikers zomaar een gebruikersaccount kunnen aanmaken met een ongeldig emailadres. Daarom wordt er, wanneer een nieuwe gebruiker wordt aangemaakt, een verficatieemail naar de gebruiker verstuurd via het emailadres dat de gebruiker heeft opgegeven bij aanmelding. Dit wordt verwezenlijkt door nieuwe gebruikers te voorzien van een extra "validated" veld. Wanneer een gebruiker pas is aangemaakt staat dit veld op vals.? Daarna wordt er een email opgestuurd. Deze email bevat een link en in deze link zit het identificatienummer van de gebruiker vervat verwijst naar een functie binnen de webdienst. De bedoeling is dat de gebruiker hierop klikt en wanneer dat gebeurd wordt het identificatienummer nagegaan en wordt het validated veld op true gezet. Zolang het validated veld op false staat, kan de gebruiker niet aanmelden.

Om de applicatie beter te kunnen testen, kan deze functionaliteit uitgeschakeld worden. In het configuratiebestand van de applicatie zit er waarde genaamd "devmode". Indien deze waarde true is, wordt de emailverificatie uitgeschakeld. Zie voorbeeld
\begin{lstlisting}
{
	"host": "localhost",
	"db": "test",
	"user": "",
	"password": "",
	"devmode": "true",
	"baseurl": "http://localhost:5000"
}
\end{lstlisting}
In dit voorbeeld is de emailverificatie uitgeschakeld.

\subsection{Tests}
De reliability van de applicatie cruciaal. Het gaat hier immers om een webapplictatie. De applicatie moet erop gebouwd zijn dat deze redelijk veel requests kan ontvangen en vooral, mochten deze requests fout opgesteld zijn, dat de applicatie deze opvangt en afhandelt zonder zelf te crashen. We zouden dit kunnen testen door zelf via de front-end foute data in te voeren, maar dit is onpraktisch. De applicatie is er immers op gebouwd om nooit foute data door te geven. Iedere data die ingevoerd wordt, wordt gevalideerd. Dit wilt echter niet zeggen dat de back-end de data ook goed valideert. In de wereld van JavaScript bestaan er hiervoor vele tools.

\section{vormgeving}

%Ik moet hier meer informatie over opzoeken
\subsection{Bootstrap}
Zelf ben ik niet zo een goede designer. Daarom heb ik besloten om deze klus uit te besteden aan een voorgekauwde collectie van CSS templates beter bekend als Bootstrap. Boostrap word meestal gebruikt om er zeker van te zijn dat de uiteindelijke website cross-browser zal werken. Op dit moment werkt Bootstrap op zowat alle moderne browsers. Deze templates zijn ook zodanig gemaakt dat de layout zich gemakkelijk aanpast aan verschillende grootten van schermen. Hete ondersteunt verschillende complexe layouts. Men kan er bijvoorbeeld voor zorgen dat de widgets automatisch in rijen staan en de breedte van het browserscherm gelijkmatig verdeeld wordt tussen de widgets.

\subsection{Filtering}
Wanneer de gebruiker teveel data heeft opgeslagen, kan de het een beetje onoverzichtelijk beginnen worden. Daarom heb ik de front-end voorzien van een handige zoek functie. De gebruiker typt een tekst in en het systeem zoekt op basis hiervan tussen de gegevens van de huidige view.

Voor de implementatie hiervan heb ik besloten om uitsluitend native javascript te gebruiken. Angular zelf heeft hier ook een zogenaamde "filter" ingebouwd, maar die was ontoereikend. Deze filter werkt door gebruik te maken van een variabele in de scope als predicaat. Onze applicatie is zodanig gebouwd dat er voor iedere view dezelfde knop en invoerveld wordt gebruikt voor het ingeven van een zoekopdracht. Dit wordt gedaan doormiddel van "partials". Deze partials worden geladen door het gebruik van de angular ng-include directive. Dit creëert een aparte scope, waardoor het predicaat ontoegankelijk is voor de getoonde data.

%Geef hier voorbeeld

\section{handleiding}

\section{Zelfevaluatie}

\end{document}
